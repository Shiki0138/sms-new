./dist/core/utils/Logger.js:                paths: ['password', 'token', 'secret', 'authorization'],
./dist/cli/config.d.ts:    token?: string;
./dist/cli/config.js:    token: zod_1.z.string().optional(),
./dist/cli/api-client.js:                ...(config.token && { Authorization: `Bearer ${config.token}` })
./dist/cli/api-client.js:    async login(email, password) {
./dist/cli/api-client.js:        const response = await this.client.post('/api/v1/auth/login', { email, password });
./dist/cli/api-client.js:    connectWebSocket(token) {
./dist/cli/api-client.js:        const url = `${wsUrl}/ws${token ? `?token=${token}` : ''}`;
./dist/cli/api-client.d.ts:    login(email: string, password: string): Promise<any>;
./dist/cli/api-client.d.ts:    connectWebSocket(token?: string): WebSocket;
./dist/storage/DatabaseManager.js:            password: config.password,
./dist/storage/RedisManager.js:            password: config.password,
./dist/storage/RedisManager.d.ts:    password?: string;
./dist/storage/DatabaseManager.d.ts:    password: string;
./dist/api/middleware/auth.js:        // Get token from header
./dist/api/middleware/auth.js:            throw new error_1.ApiError(401, 'No token provided', true);
./dist/api/middleware/auth.js:        const token = authHeader.substring(7);
./dist/api/middleware/auth.js:        // Verify token
./dist/api/middleware/auth.js:        const decoded = jsonwebtoken_1.default.verify(token, secret);
./dist/api/middleware/auth.js:        if (error instanceof jsonwebtoken_1.default.JsonWebTokenError) {
./dist/api/middleware/auth.js:            next(new error_1.ApiError(401, 'Invalid token', true));
./dist/api/middleware/auth.js:        else if (error instanceof jsonwebtoken_1.default.TokenExpiredError) {
./dist/api/middleware/auth.js:        const token = authHeader.substring(7);
./dist/api/middleware/auth.js:        const decoded = jsonwebtoken_1.default.verify(token, secret);
./dist/api/middleware/auth.js:        // Ignore token errors for optional auth
./dist/api/middleware/auth.js:        logger.debug('Optional auth token invalid', { error });
./dist/api/websocket/handler.js:    const token = new URL(request.url, `http://${request.headers.host}`).searchParams.get('token');
./dist/api/websocket/handler.js:    if (token) {
./dist/api/graphql/context.js:    // Extract user from JWT token
./dist/api/graphql/context.js:            const token = authHeader.substring(7);
./dist/api/graphql/context.js:            logger.debug('Invalid auth token in GraphQL context', { error });
./dist/api/rest/routes/auth.js:    password: zod_1.z.string().min(8)
./dist/api/rest/routes/auth.js:    password: zod_1.z.string().min(8).regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, 'Password must contain uppercase, lowercase, number and special character'),
./dist/api/rest/routes/auth.js:    const { email, password } = req.body;
./dist/api/rest/routes/auth.js:        password: await bcryptjs_1.default.hash('Admin123!', 10),
./dist/api/rest/routes/auth.js:    const isValidPassword = await bcryptjs_1.default.compare(password, mockUser.password);
./dist/api/rest/routes/auth.js:    // Generate tokens
./dist/api/rest/routes/auth.js:        tokens: {
./dist/api/rest/routes/auth.js:    const { email, password, name } = req.body;
./dist/api/rest/routes/auth.js:    const _hashedPassword = await bcryptjs_1.default.hash(password, 10);
./dist/api/rest/routes/auth.js:    // Generate tokens
./dist/api/rest/routes/auth.js:        tokens: {
./dist/api/rest/routes/auth.js:// Refresh token endpoint
./dist/api/rest/routes/auth.js:            throw new error_1.ApiError(401, 'Invalid refresh token', true);
./dist/api/rest/routes/auth.js:        // Generate new access token
./dist/api/rest/routes/auth.js:        throw new error_1.ApiError(401, 'Invalid refresh token', true);
./dist/api/rest/routes/auth.js:    // TODO: Invalidate refresh token in database
./dist/api/rest/routes/artifacts.js:    const uploadUrl = `https://storage.example.com/upload/${id}/${filename}?token=mock-token`;
./sms-service/src/middleware/auth.js:  if (req.query.api_key) {
./sms-service/src/middleware/auth.js:    return req.query.api_key;
./sms-service/src/config/index.js:  // Check JWT secret in production
./sms-service/src/config/index.js:  if (config.server.env === 'production' && config.jwt.secret === 'default-secret-change-in-production') {
./sms-service/src/providers/aws-sns-provider.js:      const { accessKeyId, secretAccessKey, region } = this.config;
./sms-service/src/providers/aws-sns-provider.js:      if (!accessKeyId || !secretAccessKey || !region) {
./sms-service/src/providers/aws-sns-provider.js:        secretAccessKey,
./tests/error-handling/lightPlan.errors.test.js:        password: 'ErrorTest123!',
./tests/error-handling/lightPlan.errors.test.js:    authToken = response.body.token;
./tests/error-handling/lightPlan.errors.test.js:    it('should handle expired token', async () => {
./tests/error-handling/lightPlan.errors.test.js:      expect(response.body.error).toContain('token');
./tests/error-handling/lightPlan.errors.test.js:    it('should handle malformed token', async () => {
./tests/error-handling/lightPlan.errors.test.js:        .set('Authorization', 'Bearer malformed.token');
./tests/unit/customers.test.js:        password: 'Admin123!'
./tests/unit/customers.test.js:          password: 'Staff123!'
./tests/unit/customers.test.js:          password: 'Staff123!'
./tests/unit/sms-routes.test.js:  'test-secret',
./tests/unit/auth.test.js:          password: 'Admin123!'
./tests/unit/auth.test.js:          password: 'wrongpassword'
./tests/unit/auth.test.js:          password: 'Admin123!'
./tests/unit/auth.test.js:        password: 'TestPass123!',
./tests/unit/auth.test.js:    test('should reject weak passwords', async () => {
./tests/unit/auth.test.js:        password: '123',
./tests/unit/auth.test.js:          password: 'Admin123!'
./tests/unit/auth.test.js:    test('should return current user with valid token', async () => {
./tests/unit/auth.test.js:    test('should reject requests without token', async () => {
./tests/unit/auth.test.js:    test('should reject requests with invalid token', async () => {
./tests/unit/auth.test.js:        .set('Authorization', 'Bearer invalid-token');
./tests/unit/auth.test.js:          password: 'Admin123!'
./tests/unit/auth.test.js:    test('should refresh token with valid refresh token', async () => {
./tests/unit/auth.test.js:    test('should reject invalid refresh token', async () => {
./tests/unit/auth.test.js:        .send({ refreshToken: 'invalid-refresh-token' });
./tests/security/lightPlan.security.test.js:        password: 'SecurePass123!',
./tests/security/lightPlan.security.test.js:    authToken = response.body.token;
./tests/security/lightPlan.security.test.js:    it('should validate CSRF tokens for state-changing operations', async () => {
./tests/security/lightPlan.security.test.js:      // Try to make request without CSRF token
./tests/security/lightPlan.security.test.js:    it('should prevent JWT token manipulation', async () => {
./tests/security/lightPlan.security.test.js:      // Try with invalid token
./tests/security/lightPlan.security.test.js:        'invalid.token.here',
./tests/security/lightPlan.security.test.js:        jwt.sign({ id: 'fake-id' }, 'wrong-secret'),
./tests/security/lightPlan.security.test.js:      for (const token of invalidTokens) {
./tests/security/lightPlan.security.test.js:          .set('Authorization', `Bearer ${token}`);
./tests/security/lightPlan.security.test.js:    it('should validate token expiration', async () => {
./tests/security/lightPlan.security.test.js:      // Create expired token
./tests/security/lightPlan.security.test.js:              password: 'wrong-password'
./tests/security/lightPlan.security.test.js:      expect(response.body.password).toBeUndefined();
./tests/security/lightPlan.security.test.js:      expect(response.body.passwordHash).toBeUndefined();
./tests/security/lightPlan.security.test.js:    it('should hash passwords properly', async () => {
./tests/security/lightPlan.security.test.js:          password: 'TestPassword123!',
./tests/security/lightPlan.security.test.js:      expect(response.body.password).toBeUndefined();
./tests/security/lightPlan.security.test.js:      expect(response.body.user.password).toBeUndefined();
./tests/security/lightPlan.security.test.js:    it('should invalidate tokens on logout', async () => {
./tests/security/lightPlan.security.test.js:      // Try to use same token
./tests/security/lightPlan.security.test.js:          password: 'SecurePass123!'
./tests/security/lightPlan.security.test.js:          password: 'SecurePass123!'
./tests/security/lightPlan.security.test.js:      expect(loginResponse1.body.token).not.toBe(loginResponse2.body.token);
./tests/security/security-tests.js:    const { email, password } = req.body;
./tests/security/security-tests.js:    if (email === 'admin@salon.com' && password === 'admin123') {
./tests/security/security-tests.js:      const token = jwt.sign({ id: 1, email, role: 'admin' }, 'test-secret');
./tests/security/security-tests.js:      return res.json({ token, user: { id: 1, email, role: 'admin' } });
./tests/security/security-tests.js:            password: 'admin123'
./tests/security/security-tests.js:        { $where: 'this.password' }
./tests/security/security-tests.js:            password: 'admin123'
./tests/security/security-tests.js:              password: 'wrongpassword'
./tests/security/security-tests.js:    test('should validate JWT token structure', async () => {
./tests/security/security-tests.js:          password: 'admin123'
./tests/security/security-tests.js:      const token = response.body.token;
./tests/security/security-tests.js:      const parts = token.split('.');
./tests/security/security-tests.js:      // Verify token can be decoded
./tests/security/security-tests.js:      const decoded = jwt.decode(token);
./tests/security/security-tests.js:    test('should reject malformed JWT tokens', async () => {
./tests/security/security-tests.js:        'invalid.token',
./tests/security/security-tests.js:        'not.a.jwt.token.at.all',
./tests/security/security-tests.js:      for (const token of malformedTokens) {
./tests/security/security-tests.js:          .set('Authorization', token ? `Bearer ${token}` : '');
./tests/security/security-tests.js:        'test-secret'
./tests/security/security-tests.js:      // Attempt to modify token payload
./tests/security/security-tests.js:      const tokenParts = userToken.split('.');
./tests/security/security-tests.js:      const header = JSON.parse(Buffer.from(tokenParts[0], 'base64').toString());
./tests/security/security-tests.js:      const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());
./tests/security/security-tests.js:      const maliciousToken = `${tokenParts[0]}.${maliciousPayloadEncoded}.${tokenParts[2]}`;
./tests/security/security-tests.js:        jwt.verify(maliciousToken, 'test-secret');
./tests/security/security-tests.js:          password: 'wrongpassword'
./tests/security/security-tests.js:      expect(response.body).not.toHaveProperty('password');
./tests/security/security-tests.js:    test('should hash passwords securely', async () => {
./tests/security/security-tests.js:      const password = 'testpassword123';
./tests/security/security-tests.js:      const hash = await bcrypt.hash(password, 10);
./tests/security/security-tests.js:      // Hash should not contain the original password
./tests/security/security-tests.js:      expect(hash).not.toContain(password);
./tests/security/security-tests.js:      // Same password should produce different hashes
./tests/security/security-tests.js:      const hash2 = await bcrypt.hash(password, 10);
./tests/security/security-tests.js:      expect(await bcrypt.compare(password, hash)).toBe(true);
./tests/security/security-tests.js:      expect(await bcrypt.compare(password, hash2)).toBe(true);
./tests/security/security-tests.js:      // Weak secret should be detected (in real implementation)
./tests/security/security-tests.js:      const weakSecrets = ['secret', '123456', 'password', 'test'];
./tests/security/security-tests.js:      const strongSecret = 'very-long-and-complex-secret-key-for-jwt-signing-2024!@#$%^&*()';
./tests/security/security-tests.js:      weakSecrets.forEach(secret => {
./tests/security/security-tests.js:        expect(secret.length).toBeLessThan(32); // Weak
./tests/security/security-tests.js:      const token = jwt.sign(payload, strongSecret);
./tests/security/security-tests.js:      const parts = token.split('.');
./tests/security/security-tests.js:      // Verify token integrity
./tests/security/security-tests.js:      const decoded = jwt.verify(token, strongSecret);
./tests/security/security-tests.js:    test('should have appropriate token expiration', async () => {
./tests/security/security-tests.js:        'test-secret',
./tests/security/security-tests.js:      const decoded = jwt.verify(shortLivedToken, 'test-secret');
./tests/security/security-tests.js:      // Wait for token to expire
./tests/security/security-tests.js:        jwt.verify(shortLivedToken, 'test-secret');
./tests/security/security-tests.js:    test('should invalidate tokens on logout', async () => {
./tests/security/security-tests.js:      // In a real implementation, we'd maintain a blacklist of invalidated tokens
./tests/security/security-tests.js:      const token = jwt.sign(
./tests/security/security-tests.js:        'test-secret',
./tests/security/security-tests.js:      // Simulate token blacklist
./tests/security/security-tests.js:      // Add token to blacklist (simulate logout)
./tests/security/security-tests.js:      blacklistedTokens.add(token);
./tests/security/security-tests.js:      // Check if token is blacklisted
./tests/security/security-tests.js:      expect(blacklistedTokens.has(token)).toBe(true);
./tests/security/security-tests.js:      if (blacklistedTokens.has(token)) {
./tests/security/security-tests.js:        jwt.verify(token, 'test-secret'); // Would normally verify
./tests/security/security-tests.js:  validateJwtToken: (token, secret) => {
./tests/security/security-tests.js:      const decoded = jwt.verify(token, secret);
./tests/integration/lightPlan.integration.test.js:        password: 'TestPass123!',
./tests/integration/lightPlan.integration.test.js:    authToken = response.body.token;
./tests/setup/test-environment.js:          password: '$2a$10$kFVBZMghl0Y4dGz1ktSjXOmGawrEj3SJZQqcXKxOvvGzFBKu1Qjmq', // admin123
./tests/setup/test-environment.js:          password: '$2a$10$kFVBZMghl0Y4dGz1ktSjXOmGawrEj3SJZQqcXKxOvvGzFBKu1Qjmq', // staff123
./tests/setup/test-environment.js:          token: 'mock.jwt.token',
./tests/test.config.js:        password: 'admin123',
./tests/test.config.js:        password: 'staff123',
./tests/test.config.js:        password: 'wrongpass'
./tests/security-audit.js:    console.log('\n🔍 Scanning for hardcoded secrets...');
./tests/security-audit.js:      /password\s*=\s*["'][^"']+["']/gi,
./tests/security-audit.js:      /secret\s*=\s*["'][^"']+["']/gi,
./tests/security-audit.js:      /token\s*=\s*["'][^"']+["']/gi
./tests/security-audit.js:          console.log(`  ⚠️  Potential secret in ${filePath}`);
./tests/security-audit.js:        console.log('  ✅ No hardcoded secrets found');
./tests/security-audit.js:console.log('2. Use environment variables for all secrets');
./tests/unit 2/middleware/auth.test.ts:    it('should authenticate valid JWT token', async () => {
./tests/unit 2/middleware/auth.test.ts:      const req = mockRequest({ authorization: `Bearer ${token}` });
./tests/unit 2/middleware/auth.test.ts:    it('should reject request with invalid token format', async () => {
./tests/unit 2/middleware/auth.test.ts:      const req = mockRequest({ authorization: 'InvalidFormat token' });
./tests/unit 2/middleware/auth.test.ts:      expect(res.json).toHaveBeenCalledWith({ error: 'Invalid token format' });
./tests/unit 2/middleware/auth.test.ts:    it('should reject request with expired token', async () => {
./tests/unit 2/middleware/auth.test.ts:    it('should reject request with invalid token signature', async () => {
./tests/unit 2/middleware/auth.test.ts:        'wrong-secret'
./tests/unit 2/middleware/auth.test.ts:      expect(res.json).toHaveBeenCalledWith({ error: 'Invalid token' });
./tests/unit 2/middleware/auth.test.ts:      const req = mockRequest({ authorization: `Bearer ${token}` });
./tests/unit 2/middleware/auth.test.ts:      const req = mockRequest({ authorization: `Bearer ${token}` });
./tests/unit 2/providers/twilio.provider.test.ts:      authToken: 'test-token'
./tests/unit 2/providers/twilio.provider.test.ts:          authToken: 'test-token'
./tests/unit 2/providers/twilio.provider.test.ts:        authToken: 'test-token',
./tests/api/lightPlan.api.test.js:        password: 'ApiTest123!',
./tests/api/lightPlan.api.test.js:    authToken = response.body.token;
./tests/api/lightPlan.api.test.js:          password: 'NewUser123!',
./tests/api/lightPlan.api.test.js:      expect(response.body).toHaveProperty('token');
./tests/api/lightPlan.api.test.js:          password: 'ApiTest123!'
./tests/api/lightPlan.api.test.js:      expect(response.body).toHaveProperty('token');
./tests/api/lightPlan.api.test.js:          password: 'WrongPassword!'
./tests/api/lightPlan.api.test.js:      expect(response.body.password).toBeUndefined();
./tests/api/lightPlan.api.test.js:    it('should handle 401 for missing auth token', async () => {
./tests/setup.js:      password: 'TestPass123!',
./tests/performance/lightPlan.performance.test.js:        password: 'PerfTest123!',
./tests/performance/lightPlan.performance.test.js:    authToken = response.body.token;
./tests/performance/load-test.js:  // Login to get auth token
./tests/performance/load-test.js:    password: ADMIN_PASSWORD
./tests/performance/load-test.js:    authToken = loginData.token;
./tests/performance/load-test.js:    return { token: authToken };
./tests/performance/load-test.js:    return { token: null };
./tests/performance/load-test.js:  if (!data.token) {
./tests/performance/load-test.js:    console.error('No auth token available');
./tests/performance/load-test.js:    'Authorization': `Bearer ${data.token}`,
./docs/design-system.js: * Comprehensive design tokens and component system for SMS
./docs/design-system.js:    this.tokens = this.getDesignTokens();
./docs/design-system.js:   * Get design tokens
./docs/design-system.js:   * @returns {Object} Design tokens
./docs/design-system.js:   * Get design token value
./docs/design-system.js:    return path.split('.').reduce((obj, key) => obj?.[key], this.tokens);
./docs/design-system.js:    const properties = flattenObject(this.tokens);
./public/js/app-new.js:    authToken = localStorage.getItem('salon_token') || sessionStorage.getItem('salon_token');
./public/js/app-new.js:    localStorage.removeItem('salon_token');
./public/js/app-new.js:    sessionStorage.removeItem('salon_token');
./public/js/app.prod.js:        this.token = localStorage.getItem('sms_token');
./public/js/app.prod.js:        if (window.location.hash && window.location.hash.includes('access_token')) {
./public/js/app.prod.js:        if (!this.token && window.location.pathname !== '/login') {
./public/js/app.prod.js:        if (this.token) {
./public/js/app.prod.js:                        'Authorization': `Bearer ${this.token}`
./public/js/app.prod.js:                    localStorage.removeItem('sms_token');
./public/js/app.prod.js:                'Authorization': `Bearer ${this.token}`
./public/js/app.prod.js:                localStorage.removeItem('sms_token');
./public/js/app.prod.js:        const password = document.getElementById('password').value;
./public/js/app.prod.js:                body: JSON.stringify({ email, password })
./public/js/app.prod.js:            localStorage.setItem('sms_token', data.accessToken);
./public/js/campaigns.js:    authToken = localStorage.getItem('salon_token') || sessionStorage.getItem('salon_token');
./public/js/campaigns.js:    localStorage.removeItem('salon_token');
./public/js/campaigns.js:    sessionStorage.removeItem('salon_token');
./public/js/auth.js:        const token = localStorage.getItem('accessToken');
./public/js/auth.js:        if (token && this.user) {
./public/js/auth.js:            // User is logged in, verify token validity
./public/js/auth.js:     * Verify token and load user data
./public/js/auth.js:        const password = document.getElementById('password').value;
./public/js/auth.js:            const response = await api.login(email, password);
./public/js/auth.js:            // Store tokens and user data
./public/js/customer-detail.js:    authToken = localStorage.getItem('salon_token') || sessionStorage.getItem('salon_token');
./public/js/customer-detail.js:    localStorage.removeItem('salon_token');
./public/js/customer-detail.js:    sessionStorage.removeItem('salon_token');
./public/js/api.js:        this.token = localStorage.getItem('accessToken');
./public/js/api.js:        if (this.token) {
./public/js/api.js:            headers.Authorization = `Bearer ${this.token}`;
./public/js/api.js:            // Handle token expiration
./public/js/api.js:                // Retry request with new token
./public/js/api.js:     * Set authentication token
./public/js/api.js:     * @param {string} token - JWT access token
./public/js/api.js:    setToken(token) {
./public/js/api.js:        this.token = token;
./public/js/api.js:        localStorage.setItem('accessToken', token);
./public/js/api.js:     * Clear authentication token
./public/js/api.js:        this.token = null;
./public/js/api.js:     * Refresh authentication token
./public/js/api.js:            throw new Error('No refresh token available');
./public/js/api.js:    async login(email, password) {
./public/js/api.js:            body: { email, password }
./public/js/api.js:    async changePassword(passwordData) {
./public/js/api.js:        return this.request('/auth/change-password', {
./public/js/api.js:            body: passwordData
./public/js/messages.js:    authToken = localStorage.getItem('salon_token') || sessionStorage.getItem('salon_token');
./public/js/messages.js:    localStorage.removeItem('salon_token');
./public/js/messages.js:    sessionStorage.removeItem('salon_token');
./public/api/index.js:      password: '$2a$10$kFVBZMghl0Y4dGz1ktSjXOmGawrEj3SJZQqcXKxOvvGzFBKu1Qjmq', // password: admin123
./public/api/index.js:  const token = authHeader && authHeader.split(' ')[1];
./public/api/index.js:  if (!token) {
./public/api/index.js:  jwt.verify(token, JWT_SECRET, (err, user) => {
./public/api/index.js:      return res.status(403).json({ error: 'Invalid token' });
./public/api/index.js:  const { email, password } = req.body;
./public/api/index.js:  const validPassword = await bcrypt.compare(password, user.password);
./public/api/index.js:  const token = jwt.sign(
./public/api/index.js:    token,
./public/src/core/utils/Logger.ts:        paths: ['password', 'token', 'secret', 'authorization'],
./public/src/frontend/app.prod.js:        this.token = localStorage.getItem('sms_token');
./public/src/frontend/app.prod.js:        if (window.location.hash && window.location.hash.includes('access_token')) {
./public/src/frontend/app.prod.js:        if (!this.token && window.location.pathname !== '/login') {
./public/src/frontend/app.prod.js:        if (this.token) {
./public/src/frontend/app.prod.js:                        'Authorization': `Bearer ${this.token}`
./public/src/frontend/app.prod.js:                    localStorage.removeItem('sms_token');
./public/src/frontend/app.prod.js:                'Authorization': `Bearer ${this.token}`
./public/src/frontend/app.prod.js:                localStorage.removeItem('sms_token');
./public/src/frontend/app.prod.js:        const password = document.getElementById('password').value;
./public/src/frontend/app.prod.js:                body: JSON.stringify({ email, password })
./public/src/frontend/app.prod.js:            localStorage.setItem('sms_token', data.token);
./public/src/frontend/app.js:        this.token = localStorage.getItem('sms_token');
./public/src/frontend/app.js:        if (!this.token && window.location.pathname !== '/login') {
./public/src/frontend/app.js:        if (this.token) {
./public/src/frontend/app.js:                        'Authorization': `Bearer ${this.token}`
./public/src/frontend/app.js:                    localStorage.removeItem('sms_token');
./public/src/frontend/app.js:                'Authorization': `Bearer ${this.token}`
./public/src/frontend/app.js:                localStorage.removeItem('sms_token');
./public/src/frontend/app.js:        const password = document.getElementById('password').value;
./public/src/frontend/app.js:                body: JSON.stringify({ email, password })
./public/src/frontend/app.js:            localStorage.setItem('sms_token', data.token);
./public/src/backend/server.js:      password: '$2a$10$kFVBZMghl0Y4dGz1ktSjXOmGawrEj3SJZQqcXKxOvvGzFBKu1Qjmq', // password: admin123
./public/src/backend/server.js:const JWT_SECRET = 'your-secret-key-change-in-production';
./public/src/backend/server.js:  const token = authHeader && authHeader.split(' ')[1];
./public/src/backend/server.js:  if (!token) {
./public/src/backend/server.js:  jwt.verify(token, JWT_SECRET, (err, user) => {
./public/src/backend/server.js:      return res.status(403).json({ error: 'Invalid token' });
./public/src/backend/server.js:  const { email, password } = req.body;
./public/src/backend/server.js:  const validPassword = await bcrypt.compare(password, user.password);
./public/src/backend/server.js:  const token = jwt.sign(
./public/src/backend/server.js:    token,
./public/src/cli/api-client.ts:        ...(config.token && { Authorization: `Bearer ${config.token}` })
./public/src/cli/api-client.ts:  async login(email: string, password: string): Promise<any> {
./public/src/cli/api-client.ts:    const response = await this.client.post('/api/v1/auth/login', { email, password });
./public/src/cli/api-client.ts:  connectWebSocket(token?: string): WebSocket {
./public/src/cli/api-client.ts:    const url = `${wsUrl}/ws${token ? `?token=${token}` : ''}`;
./public/src/cli/config.ts:  token?: string;
./public/src/cli/config.ts:  token: z.string().optional(),
./public/src/storage/RedisManager.ts:  password?: string;
./public/src/storage/RedisManager.ts:      password: config.password,
./public/src/storage/DatabaseManager.ts:  password: string;
./public/src/storage/DatabaseManager.ts:      password: config.password,
./public/src/api/middleware/auth.ts:    // Get token from header
./public/src/api/middleware/auth.ts:      throw new ApiError(401, 'No token provided', true);
./public/src/api/middleware/auth.ts:    const token = authHeader.substring(7);
./public/src/api/middleware/auth.ts:    // Verify token
./public/src/api/middleware/auth.ts:    const decoded = jwt.verify(token, secret) as any;
./public/src/api/middleware/auth.ts:      next(new ApiError(401, 'Invalid token', true));
./public/src/api/middleware/auth.ts:    const token = authHeader.substring(7);
./public/src/api/middleware/auth.ts:    const decoded = jwt.verify(token, secret) as any;
./public/src/api/middleware/auth.ts:    // Ignore token errors for optional auth
./public/src/api/middleware/auth.ts:    logger.debug('Optional auth token invalid', { error });
./public/src/api/websocket/handler.ts:  const token = new URL(request.url, `http://${request.headers.host}`).searchParams.get('token');
./public/src/api/websocket/handler.ts:  if (token) {
./public/src/api/websocket/handler.ts:        token,
./public/src/api/graphql/context.ts:  // Extract user from JWT token
./public/src/api/graphql/context.ts:      const token = authHeader.substring(7);
./public/src/api/graphql/context.ts:        token,
./public/src/api/graphql/context.ts:      logger.debug('Invalid auth token in GraphQL context', { error });
./public/src/api/rest/routes/artifacts.ts:    const uploadUrl = `https://storage.example.com/upload/${id}/${filename}?token=mock-token`;
./public/src/api/rest/routes/auth.ts:  password: z.string().min(8)
./public/src/api/rest/routes/auth.ts:  password: z.string().min(8).regex(
./public/src/api/rest/routes/auth.ts:    const { email, password } = req.body;
./public/src/api/rest/routes/auth.ts:      password: await bcrypt.hash('Admin123!', 10),
./public/src/api/rest/routes/auth.ts:    const isValidPassword = await bcrypt.compare(password, mockUser.password);
./public/src/api/rest/routes/auth.ts:    // Generate tokens
./public/src/api/rest/routes/auth.ts:      tokens: {
./public/src/api/rest/routes/auth.ts:    const { email, password, name } = req.body;
./public/src/api/rest/routes/auth.ts:    const _hashedPassword = await bcrypt.hash(password, 10);
./public/src/api/rest/routes/auth.ts:    // Generate tokens
./public/src/api/rest/routes/auth.ts:      tokens: {
./public/src/api/rest/routes/auth.ts:// Refresh token endpoint
./public/src/api/rest/routes/auth.ts:        throw new ApiError(401, 'Invalid refresh token', true);
./public/src/api/rest/routes/auth.ts:      // Generate new access token
./public/src/api/rest/routes/auth.ts:      throw new ApiError(401, 'Invalid refresh token', true);
./public/src/api/rest/routes/auth.ts:  // TODO: Invalidate refresh token in database
./salon-light-plan/dist/assets 2/index-C07hdYd_.js: */const L1=[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]],Lo=ae("x",L1),Y1=({error:n})=>x.jsx("div",{className:"min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100",children:x.jsx("div",{className:"max-w-md w-full bg-white rounded-2xl shadow-xl p-8",children:x.jsxs("div",{className:"flex flex-col items-center text-center",children:[x.jsx("div",{className:"mb-6 p-4 bg-red-100 rounded-full",children:x.jsx(C1,{className:"h-12 w-12 text-red-600"})}),x.jsx("h1",{className:"text-2xl font-bold text-gray-900 mb-2",children:"エラーが発生しました"}),x.jsx("p",{className:"text-gray-600 mb-6",children:"申し訳ございません。アプリケーションでエラーが発生しました。"}),!1,x.jsxs("div",{className:"flex flex-col sm:flex-row gap-3 w-full",children:[x.jsxs("button",{onClick:()=>window.location.reload(),className:"flex-1 px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center space-x-2",children:[x.jsx(z1,{className:"h-4 w-4"}),x.jsx("span",{children:"ページを再読み込み"})]}),x.jsxs("button",{onClick:()=>window.location.href="/",className:"flex-1 px-6 py-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors flex items-center justify-center space-x-2",children:[x.jsx(x1,{className:"h-4 w-4"}),x.jsx("span",{children:"ホームに戻る"})]})]}),x.jsx("p",{className:"mt-6 text-sm text-gray-500",children:"問題が続く場合は、サポートまでお問い合わせください。"})]})})});class Q1 extends w.Component{state={hasError:!1,error:null,errorCount:0};static getDerivedStateFromError(s){const r=parseInt(sessionStorage.getItem("errorCount")||"0")+1;return sessionStorage.setItem("errorCount",r.toString()),{hasError:!0,error:s,errorCount:r}}componentDidCatch(s,r){console.error("ErrorBoundary: Uncaught error:",s,r),console.error("ErrorBoundary: Component Stack:",r.componentStack),console.error("ErrorBoundary: Error message:",s.message),console.error("ErrorBoundary: Error stack:",s.stack),s.message?.includes("Missing Supabase environment variables")&&console.warn("ErrorBoundary: Supabase not configured. Running in offline mode.")}resetError=()=>{sessionStorage.setItem("errorCount","0"),this.setState({hasError:!1,error:null,errorCount:0}),window.location.href="/"};render(){return this.state.hasError?this.props.fallback?this.props.fallback:this.state.errorCount>3?x.jsx("div",{className:"min-h-screen flex items-center justify-center bg-gray-50 p-4",children:x.jsxs("div",{className:"text-center max-w-md",children:[x.jsx("h1",{className:"text-2xl font-bold text-gray-900 mb-4",children:"申し訳ございません"}),x.jsx("p",{className:"text-gray-600 mb-6",children:"アプリケーションで問題が発生しています。 ブラウザのキャッシュをクリアしてから再度お試しください。"}),x.jsx("button",{onClick:()=>{sessionStorage.clear(),localStorage.clear(),window.location.href="/"},className:"px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700",children:"キャッシュをクリアして再読み込み"})]})}):x.jsx(Y1,{error:this.state.error||void 0,resetError:this.resetError}):this.props.children}}const G1="https://your-project.supabase.co",N0="your_supabase_anon_key",hn=!!N0,k1=()=>({auth:{getSession:async()=>({data:{session:null},error:null}),getUser:async()=>({data:{user:null},error:null}),signInWithPassword:async()=>({data:{user:null,session:null},error:{message:"Supabase未設定"}}),signUp:async()=>({data:{user:null,session:null},error:{message:"Supabase未設定"}}),signOut:async()=>({error:null}),onAuthStateChange:()=>({data:{subscription:{unsubscribe:()=>{}}}})},from:()=>({select:()=>({eq:()=>({single:async()=>({data:null,error:{message:"Supabase未設定"}}),maybeSingle:async()=>({data:null,error:null})}),order:()=>({limit:()=>({range:async()=>({data:[],error:null})})})}),insert:async()=>({data:null,error:{message:"Supabase未設定"}}),update:async()=>({data:null,error:{message:"Supabase未設定"}}),delete:async()=>({data:null,error:{message:"Supabase未設定"}})})}),Sa=hn?Fh(G1,N0,{auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}}):k1(),Rb=()=>hn?null:{title:"⚠️ Supabase設定が必要です",message:"環境変数 VITE_SUPABASE_URL と VITE_SUPABASE_ANON_KEY を設定してください。",isDevelopment:!1},xo={signIn:async(n,s)=>{if(!hn)throw new Error("Supabaseが設定されていません。環境変数を確認してください。");const{data:r,error:o}=await Sa.auth.signInWithPassword({email:n,password:s});if(o)throw new Error(o.message);return r},signUp:async(n,s,r)=>{if(!hn)throw new Error("Supabaseが設定されていません。環境変数を確認してください。");try{const{data:o,error:f}=await Sa.auth.signUp({email:n,password:s});if(f)throw new Error(f.message);if(!o.user)throw new Error("ユーザー作成に失敗しました");await new Promise(y=>setTimeout(y,1e3));const{data:d,error:g}=await Sa.from("tenants").insert({name:r,plan_type:"light",email:n,settings:{business_name:r,business_type:"beauty_salon",timezone:"Asia/Tokyo"}}).select().single();if(g)throw console.error("Tenant creation error:",g),new Error(`テナント作成エラー: ${g.message}`);const{error:p}=await Sa.from("users").insert({auth_id:o.user.id,tenant_id:d.id,email:n,full_name:r+" オーナー",role:"owner"}).select().single();if(p)throw console.error("User record creation error:",p),new Error(`ユーザー作成エラー: ${p.message}`);return{user:o.user,tenant:d}}catch(o){throw console.error("SignUp error:",o),o}},signOut:async()=>{if(!hn)return;const{error:n}=await Sa.auth.signOut();if(n)throw new Error(n.message)},getCurrentUser:async()=>{if(!hn)return null;const{data:{user:n},error:s}=await Sa.auth.getUser();if(s)throw new Error(s.message);return n}},z0=w.createContext(void 0),X1=({children:n})=>{const[s,r]=w.useState(null),[o,f]=w.useState(null),[d,g]=w.useState("light"),[p,y]=w.useState(!0),[b,E]=w.useState(null),m=async N=>{try{console.log("Fetching tenant info for user:",N);const{data:j,error:G}=await Sa.from("users").select(`
./salon-light-plan/dist/assets 2/data-vendor-BeNRgWeM.js:  });`;class gs{constructor(e,t){var s;this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=bt,this.heartbeatIntervalMs=25e3,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=rt,this.ref=0,this.logger=rt,this.conn=null,this.sendBuffer=[],this.serializer=new os,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._resolveFetch=i=>{let o;return i?o=i:typeof fetch>"u"?o=(...a)=>ue(async()=>{const{default:l}=await Promise.resolve().then(()=>ie);return{default:l}},void 0).then(({default:l})=>l(...a)):o=fetch,(...a)=>o(...a)},this.endPoint=`${e}/${Oe.websocket}`,this.httpEndpoint=Et(e),t?.transport?this.transport=t.transport:this.transport=null,t?.params&&(this.params=t.params),t?.timeout&&(this.timeout=t.timeout),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),t?.heartbeatIntervalMs&&(this.heartbeatIntervalMs=t.heartbeatIntervalMs);const r=(s=t?.params)===null||s===void 0?void 0:s.apikey;if(r&&(this.accessTokenValue=r,this.apiKey=r),this.reconnectAfterMs=t?.reconnectAfterMs?t.reconnectAfterMs:i=>[1e3,2e3,5e3,1e4][i-1]||1e4,this.encode=t?.encode?t.encode:(i,o)=>o(JSON.stringify(i)),this.decode=t?.decode?t.decode:this.serializer.decode.bind(this.serializer),this.reconnectTimer=new kt(async()=>{this.disconnect(),this.connect()},this.reconnectAfterMs),this.fetch=this._resolveFetch(t?.fetch),t?.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.worker=t?.worker||!1,this.workerUrl=t?.workerUrl}this.accessToken=t?.accessToken||null}connect(){if(!this.conn){if(this.transport||(this.transport=ts),!this.transport)throw new Error("No transport provided");this.conn=new this.transport(this.endpointURL()),this.setupConnection()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:is}))}disconnect(e,t){this.conn&&(this.conn.onclose=function(){},e?this.conn.close(e,t??""):this.conn.close(),this.conn=null,this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.reset(),this.channels.forEach(s=>s.teardown()))}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case le.connecting:return W.Connecting;case le.open:return W.Open;case le.closing:return W.Closing;default:return W.Closed}}isConnected(){return this.connectionState()===W.Open}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new qe(`realtime:${e}`,t,this);return this.channels.push(i),i}}push(e){const{topic:t,event:s,payload:r,ref:i}=e,o=()=>{this.encode(e,a=>{var l;(l=this.conn)===null||l===void 0||l.send(a)})};this.log("push",`${t} ${s} (${i})`,r),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(e=null){let t=e||this.accessToken&&await this.accessToken()||this.accessTokenValue;this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(s=>{const r={access_token:t,version:rs};t&&s.updateJoinPayload(r),s.joinedOnce&&s._isJoined()&&s._push(C.access_token,{access_token:t})}))}async sendHeartbeat(){var e;if(!this.isConnected()){this.heartbeatCallback("disconnected");return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection"),this.heartbeatCallback("timeout"),(e=this.conn)===null||e===void 0||e.close(ns,"hearbeat timeout");return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef}),this.heartbeatCallback("sent"),await this.setAuth()}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}setupConnection(){this.conn&&(this.conn.binaryType="arraybuffer",this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e))}_onConnMessage(e){this.decode(e.data,t=>{let{topic:s,event:r,payload:i,ref:o}=t;s==="phoenix"&&r==="phx_reply"&&this.heartbeatCallback(t.payload.status=="ok"?"ok":"error"),o&&o===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null),this.log("receive",`${i.status||""} ${s} ${r} ${o&&"("+o+")"||""}`,i),Array.from(this.channels).filter(a=>a._isMember(s)).forEach(a=>a._trigger(r,i,o)),this.stateChangeCallbacks.message.forEach(a=>a(t))})}_onConnOpen(){this.log("transport",`connected to ${this.endpointURL()}`),this.flushSendBuffer(),this.reconnectTimer.reset(),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this.stateChangeCallbacks.open.forEach(e=>e())}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this.workerRef.terminate()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(e){this.log("transport","close",e),this._triggerChanError(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.scheduleTimeout(),this.stateChangeCallbacks.close.forEach(t=>t(e))}_onConnError(e){this.log("transport",`${e}`),this._triggerChanError(),this.stateChangeCallbacks.error.forEach(t=>t(e))}_triggerChanError(){this.channels.forEach(e=>e._trigger(C.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([fs],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}}class Be extends Error{constructor(e){super(e),this.__isStorageError=!0,this.name="StorageError"}}function j(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}class ps extends Be{constructor(e,t){super(e),this.name="StorageApiError",this.status=t}toJSON(){return{name:this.name,message:this.message,status:this.status}}}class $e extends Be{constructor(e,t){super(e),this.name="StorageUnknownError",this.originalError=t}}var vs=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const Tt=n=>{let e;return n?e=n:typeof fetch>"u"?e=(...t)=>ue(async()=>{const{default:s}=await Promise.resolve().then(()=>ie);return{default:s}},void 0).then(({default:s})=>s(...t)):e=fetch,(...t)=>e(...t)},_s=()=>vs(void 0,void 0,void 0,function*(){return typeof Response>"u"?(yield ue(()=>Promise.resolve().then(()=>ie),void 0)).Response:Response}),Re=n=>{if(Array.isArray(n))return n.map(t=>Re(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));e[r]=Re(s)}),e};var K=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const be=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),ws=(n,e,t)=>K(void 0,void 0,void 0,function*(){const s=yield _s();n instanceof s&&!t?.noResolveJson?n.json().then(r=>{e(new ps(be(r),n.status||500))}).catch(r=>{e(new $e(be(r),r))}):e(new $e(be(n),n))}),ys=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json"},e?.headers),s&&(r.body=JSON.stringify(s)),Object.assign(Object.assign({},r),t))};function de(n,e,t,s,r,i){return K(this,void 0,void 0,function*(){return new Promise((o,a)=>{n(t,ys(e,s,r,i)).then(l=>{if(!l.ok)throw l;return s?.noResolveJson?l:l.json()}).then(l=>o(l)).catch(l=>ws(l,a,s))})})}function _e(n,e,t,s){return K(this,void 0,void 0,function*(){return de(n,"GET",e,t,s)})}function D(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"POST",e,s,r,t)})}function ms(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"PUT",e,s,r,t)})}function bs(n,e,t,s){return K(this,void 0,void 0,function*(){return de(n,"HEAD",e,Object.assign(Object.assign({},t),{noResolveJson:!0}),s)})}function jt(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"DELETE",e,s,r,t)})}var A=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const ks={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},it={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};class Ss{constructor(e,t={},s,r){this.url=e,this.headers=t,this.bucketId=s,this.fetch=Tt(r)}uploadOrUpdate(e,t,s,r){return A(this,void 0,void 0,function*(){try{let i;const o=Object.assign(Object.assign({},it),r);let a=Object.assign(Object.assign({},this.headers),e==="POST"&&{"x-upsert":String(o.upsert)});const l=o.metadata;typeof Blob<"u"&&s instanceof Blob?(i=new FormData,i.append("cacheControl",o.cacheControl),l&&i.append("metadata",this.encodeMetadata(l)),i.append("",s)):typeof FormData<"u"&&s instanceof FormData?(i=s,i.append("cacheControl",o.cacheControl),l&&i.append("metadata",this.encodeMetadata(l))):(i=s,a["cache-control"]=`max-age=${o.cacheControl}`,a["content-type"]=o.contentType,l&&(a["x-metadata"]=this.toBase64(this.encodeMetadata(l)))),r?.headers&&(a=Object.assign(Object.assign({},a),r.headers));const c=this._removeEmptyFolders(t),h=this._getFinalPath(c),u=yield this.fetch(`${this.url}/object/${h}`,Object.assign({method:e,body:i,headers:a},o?.duplex?{duplex:o.duplex}:{})),d=yield u.json();return u.ok?{data:{path:c,id:d.Id,fullPath:d.Key},error:null}:{data:null,error:d}}catch(i){if(j(i))return{data:null,error:i};throw i}})}upload(e,t,s){return A(this,void 0,void 0,function*(){return this.uploadOrUpdate("POST",e,t,s)})}uploadToSignedUrl(e,t,s,r){return A(this,void 0,void 0,function*(){const i=this._removeEmptyFolders(e),o=this._getFinalPath(i),a=new URL(this.url+`/object/upload/sign/${o}`);a.searchParams.set("token",t);try{let l;const c=Object.assign({upsert:it.upsert},r),h=Object.assign(Object.assign({},this.headers),{"x-upsert":String(c.upsert)});typeof Blob<"u"&&s instanceof Blob?(l=new FormData,l.append("cacheControl",c.cacheControl),l.append("",s)):typeof FormData<"u"&&s instanceof FormData?(l=s,l.append("cacheControl",c.cacheControl)):(l=s,h["cache-control"]=`max-age=${c.cacheControl}`,h["content-type"]=c.contentType);const u=yield this.fetch(a.toString(),{method:"PUT",body:l,headers:h}),d=yield u.json();return u.ok?{data:{path:i,fullPath:d.Key},error:null}:{data:null,error:d}}catch(l){if(j(l))return{data:null,error:l};throw l}})}createSignedUploadUrl(e,t){return A(this,void 0,void 0,function*(){try{let s=this._getFinalPath(e);const r=Object.assign({},this.headers);t?.upsert&&(r["x-upsert"]="true");const i=yield D(this.fetch,`${this.url}/object/upload/sign/${s}`,{},{headers:r}),o=new URL(this.url+i.url),a=o.searchParams.get("token");if(!a)throw new Be("No token returned by API");return{data:{signedUrl:o.toString(),path:e,token:a},error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}update(e,t,s){return A(this,void 0,void 0,function*(){return this.uploadOrUpdate("PUT",e,t,s)})}move(e,t,s){return A(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:e,destinationKey:t,destinationBucket:s?.destinationBucket},{headers:this.headers}),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}copy(e,t,s){return A(this,void 0,void 0,function*(){try{return{data:{path:(yield D(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:e,destinationKey:t,destinationBucket:s?.destinationBucket},{headers:this.headers})).Key},error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}createSignedUrl(e,t,s){return A(this,void 0,void 0,function*(){try{let r=this._getFinalPath(e),i=yield D(this.fetch,`${this.url}/object/sign/${r}`,Object.assign({expiresIn:t},s?.transform?{transform:s.transform}:{}),{headers:this.headers});const o=s?.download?`&download=${s.download===!0?"":s.download}`:"";return i={signedUrl:encodeURI(`${this.url}${i.signedURL}${o}`)},{data:i,error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}createSignedUrls(e,t,s){return A(this,void 0,void 0,function*(){try{const r=yield D(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn:t,paths:e},{headers:this.headers}),i=s?.download?`&download=${s.download===!0?"":s.download}`:"";return{data:r.map(o=>Object.assign(Object.assign({},o),{signedUrl:o.signedURL?encodeURI(`${this.url}${o.signedURL}${i}`):null})),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}download(e,t){return A(this,void 0,void 0,function*(){const r=typeof t?.transform<"u"?"render/image/authenticated":"object",i=this.transformOptsToQueryString(t?.transform||{}),o=i?`?${i}`:"";try{const a=this._getFinalPath(e);return{data:yield(yield _e(this.fetch,`${this.url}/${r}/${a}${o}`,{headers:this.headers,noResolveJson:!0})).blob(),error:null}}catch(a){if(j(a))return{data:null,error:a};throw a}})}info(e){return A(this,void 0,void 0,function*(){const t=this._getFinalPath(e);try{const s=yield _e(this.fetch,`${this.url}/object/info/${t}`,{headers:this.headers});return{data:Re(s),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}exists(e){return A(this,void 0,void 0,function*(){const t=this._getFinalPath(e);try{return yield bs(this.fetch,`${this.url}/object/${t}`,{headers:this.headers}),{data:!0,error:null}}catch(s){if(j(s)&&s instanceof $e){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}})}getPublicUrl(e,t){const s=this._getFinalPath(e),r=[],i=t?.download?`download=${t.download===!0?"":t.download}`:"";i!==""&&r.push(i);const a=typeof t?.transform<"u"?"render/image":"object",l=this.transformOptsToQueryString(t?.transform||{});l!==""&&r.push(l);let c=r.join("&");return c!==""&&(c=`?${c}`),{data:{publicUrl:encodeURI(`${this.url}/${a}/public/${s}${c}`)}}}remove(e){return A(this,void 0,void 0,function*(){try{return{data:yield jt(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:e},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}list(e,t,s){return A(this,void 0,void 0,function*(){try{const r=Object.assign(Object.assign(Object.assign({},ks),t),{prefix:e||""});return{data:yield D(this.fetch,`${this.url}/object/list/${this.bucketId}`,r,{headers:this.headers},s),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}encodeMetadata(e){return JSON.stringify(e)}toBase64(e){return typeof Buffer<"u"?Buffer.from(e).toString("base64"):btoa(e)}_getFinalPath(e){return`${this.bucketId}/${e}`}_removeEmptyFolders(e){return e.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(e){const t=[];return e.width&&t.push(`width=${e.width}`),e.height&&t.push(`height=${e.height}`),e.resize&&t.push(`resize=${e.resize}`),e.format&&t.push(`format=${e.format}`),e.quality&&t.push(`quality=${e.quality}`),t.join("&")}}const Es="2.7.1",Ts={"X-Client-Info":`storage-js/${Es}`};var Q=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,[])).next())})};class js{constructor(e,t={},s){this.url=e,this.headers=Object.assign(Object.assign({},Ts),t),this.fetch=Tt(s)}listBuckets(){return Q(this,void 0,void 0,function*(){try{return{data:yield _e(this.fetch,`${this.url}/bucket`,{headers:this.headers}),error:null}}catch(e){if(j(e))return{data:null,error:e};throw e}})}getBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield _e(this.fetch,`${this.url}/bucket/${e}`,{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}createBucket(e,t={public:!1}){return Q(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/bucket`,{id:e,name:e,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:this.headers}),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}updateBucket(e,t){return Q(this,void 0,void 0,function*(){try{return{data:yield ms(this.fetch,`${this.url}/bucket/${e}`,{id:e,name:e,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:this.headers}),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}emptyBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/bucket/${e}/empty`,{},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}deleteBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield jt(this.fetch,`${this.url}/bucket/${e}`,{},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}}class Ps extends js{constructor(e,t={},s){super(e,t,s)}from(e){return new Ss(this.url,this.headers,e,this.fetch)}}const Os="2.52.1";let ae="";typeof Deno<"u"?ae="deno":typeof document<"u"?ae="web":typeof navigator<"u"&&navigator.product==="ReactNative"?ae="react-native":ae="node";const As={"X-Client-Info":`supabase-js-${ae}/${Os}`},$s={headers:As},Rs={schema:"public"},Cs={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},xs={};var Is=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const Us=n=>{let e;return n?e=n:typeof fetch>"u"?e=pt:e=fetch,(...t)=>e(...t)},Ls=()=>typeof Headers>"u"?vt:Headers,Ds=(n,e,t)=>{const s=Us(t),r=Ls();return(i,o)=>Is(void 0,void 0,void 0,function*(){var a;const l=(a=yield e())!==null&&a!==void 0?a:n;let c=new r(o?.headers);return c.has("apikey")||c.set("apikey",n),c.has("Authorization")||c.set("Authorization",`Bearer ${l}`),s(i,Object.assign(Object.assign({},o),{headers:c}))})};var qs=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,[])).next())})};function Bs(n){return n.endsWith("/")?n:n+"/"}function Ns(n,e){var t,s;const{db:r,auth:i,realtime:o,global:a}=n,{db:l,auth:c,realtime:h,global:u}=e,d={db:Object.assign(Object.assign({},l),r),auth:Object.assign(Object.assign({},c),i),realtime:Object.assign(Object.assign({},h),o),global:Object.assign(Object.assign(Object.assign({},u),a),{headers:Object.assign(Object.assign({},(t=u?.headers)!==null&&t!==void 0?t:{}),(s=a?.headers)!==null&&s!==void 0?s:{})}),accessToken:()=>qs(this,void 0,void 0,function*(){return""})};return n.accessToken?d.accessToken=n.accessToken:delete d.accessToken,d}const Pt="2.71.1",te=30*1e3,Ce=3,ke=Ce*te,Ms="http://localhost:9999",Fs="supabase.auth.token",Ws={"X-Client-Info":`gotrue-js/${Pt}`},xe="X-Supabase-Api-Version",Ot={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},Ks=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,zs=600*1e3;class Ne extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function _(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class Js extends Ne{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function Hs(n){return _(n)&&n.name==="AuthApiError"}class At extends Ne{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class B extends Ne{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class L extends B{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function Gs(n){return _(n)&&n.name==="AuthSessionMissingError"}class ge extends B{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class pe extends B{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class ve extends B{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function Vs(n){return _(n)&&n.name==="AuthImplicitGrantRedirectError"}class nt extends B{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class Ie extends B{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function Se(n){return _(n)&&n.name==="AuthRetryableFetchError"}class ot extends B{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class Ue extends B{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const we="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),at=` 	
./salon-light-plan/dist/assets 2/data-vendor-BeNRgWeM.js:\r=`.split(""),Qs=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<at.length;e+=1)n[at[e].charCodeAt(0)]=-2;for(let e=0;e<we.length;e+=1)n[we[e].charCodeAt(0)]=e;return n})();function lt(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(we[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(we[s]),e.queuedBits-=6}}function $t(n,e,t){const s=Qs[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function ct(n){const e=[],t=o=>{e.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=o=>{Zs(o,s,t)};for(let o=0;o<n.length;o+=1)$t(n.charCodeAt(o),r,i);return e.join("")}function Xs(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function Ys(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}Xs(s,e)}}function Zs(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function er(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)$t(n.charCodeAt(r),t,s);return new Uint8Array(e)}function tr(n){const e=[];return Ys(n,t=>e.push(t)),new Uint8Array(e)}function sr(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>lt(r,t,s)),lt(null,t,s),e.join("")}function rr(n){return Math.round(Date.now()/1e3)+n}function ir(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(n){const e=Math.random()*16|0;return(n=="x"?e:e&3|8).toString(16)})}const R=()=>typeof window<"u"&&typeof document<"u",N={tested:!1,writable:!1},Rt=()=>{if(!R())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(N.tested)return N.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),N.tested=!0,N.writable=!0}catch{N.tested=!0,N.writable=!1}return N.writable};function nr(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,i)=>{e[i]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const Ct=n=>{let e;return n?e=n:typeof fetch>"u"?e=(...t)=>ue(async()=>{const{default:s}=await Promise.resolve().then(()=>ie);return{default:s}},void 0).then(({default:s})=>s(...t)):e=fetch,(...t)=>e(...t)},or=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",se=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},M=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},U=async(n,e)=>{await n.removeItem(e)};class ye{constructor(){this.promise=new ye.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}ye.promiseConstructor=Promise;function Ee(n){const e=n.split(".");if(e.length!==3)throw new Ue("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!Ks.test(e[s]))throw new Ue("JWT not in base64url format");return{header:JSON.parse(ct(e[0])),payload:JSON.parse(ct(e[1])),signature:er(e[2]),raw:{header:e[0],payload:e[1]}}}async function ar(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function lr(n,e){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const o=await n(i);if(!e(i,null,o)){s(o);return}}catch(o){if(!e(i,o)){r(o);return}}})()})}function cr(n){return("0"+n.toString(16)).substr(-2)}function hr(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let i=0;i<56;i++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,cr).join("")}async function ur(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function dr(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await ur(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function X(n,e,t=!1){const s=hr();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await se(n,`${e}-code-verifier`,r);const i=await dr(s);return[i,s===i?"plain":"s256"]}const fr=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function gr(n){const e=n.headers.get(xe);if(!e||!e.match(fr))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function pr(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function vr(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const _r=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function Y(n){if(!_r.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function Te(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function ht(n){return JSON.parse(JSON.stringify(n))}var wr=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};const F=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),yr=[502,503,504];async function ut(n){var e;if(!or(n))throw new Ie(F(n),0);if(yr.includes(n.status))throw new Ie(F(n),n.status);let t;try{t=await n.json()}catch(i){throw new At(F(i),i)}let s;const r=gr(n);if(r&&r.getTime()>=Ot["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new ot(F(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new L}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((i,o)=>i&&typeof o=="string",!0))throw new ot(F(t),n.status,t.weak_password.reasons);throw new Js(F(t),n.status||500,s)}const mr=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function y(n,e,t,s){var r;const i=Object.assign({},s?.headers);i[xe]||(i[xe]=Ot["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const o=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const a=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",l=await br(n,e,t+a,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(l):{data:Object.assign({},l),error:null}}async function br(n,e,t,s,r,i){const o=mr(e,s,r,i);let a;try{a=await n(t,Object.assign({},o))}catch(l){throw console.error(l),new Ie(F(l),0)}if(a.ok||await ut(a),s?.noResolveJson)return a;try{return await a.json()}catch(l){await ut(l)}}function x(n){var e;let t=null;Tr(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=rr(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function dt(n){const e=x(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function q(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function kr(n){return{data:n,error:null}}function Sr(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i}=n,o=wr(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),a={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i},l=Object.assign({},o);return{data:{properties:a,user:l},error:null}}function Er(n){return n}function Tr(n){return n.access_token&&n.refresh_token&&n.expires_in}const je=["global","local","others"];var jr=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class Pr{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=Ct(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)}}async signOut(e,t=je[0]){if(je.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${je.join(", ")}`);try{return await y(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(_(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await y(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=jr(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await y(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:Sr,redirectTo:t?.redirectTo})}catch(t){if(_(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await y(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:q})}catch(t){if(_(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,i,o,a,l;try{const c={nextPage:null,lastPage:0,total:0},h=await y(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:Er});if(h.error)throw h.error;const u=await h.json(),d=(o=h.headers.get("x-total-count"))!==null&&o!==void 0?o:0,f=(l=(a=h.headers.get("link"))===null||a===void 0?void 0:a.split(","))!==null&&l!==void 0?l:[];return f.length>0&&(f.forEach(g=>{const w=parseInt(g.split(";")[0].split("=")[1].substring(0,1)),v=JSON.parse(g.split(";")[1].split("=")[1]);c[`${v}Page`]=w}),c.total=parseInt(d)),{data:Object.assign(Object.assign({},u),c),error:null}}catch(c){if(_(c))return{data:{users:[]},error:c};throw c}}async getUserById(e){Y(e);try{return await y(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:q})}catch(t){if(_(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){Y(e);try{return await y(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){Y(e);try{return await y(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){Y(e.userId);try{const{data:t,error:s}=await y(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(_(t))return{data:null,error:t};throw t}}async _deleteFactor(e){Y(e.userId),Y(e.id);try{return{data:await y(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(_(t))return{data:null,error:t};throw t}}}function ft(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}function Or(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}const Z={debug:!!(globalThis&&Rt()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class xt extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class Ar extends xt{}async function $r(n,e,t){Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),Z.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new Ar(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(Z.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}Or();const Rr={url:Ms,storageKey:Fs,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:Ws,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1};async function gt(n,e,t){return await t()}const ee={};class he{constructor(e){var t,s;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log,this.instanceID=he.nextInstanceID,he.nextInstanceID+=1,this.instanceID>0&&R()&&console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");const r=Object.assign(Object.assign({},Rr),e);if(this.logDebugMessages=!!r.debug,typeof r.debug=="function"&&(this.logger=r.debug),this.persistSession=r.persistSession,this.storageKey=r.storageKey,this.autoRefreshToken=r.autoRefreshToken,this.admin=new Pr({url:r.url,headers:r.headers,fetch:r.fetch}),this.url=r.url,this.headers=r.headers,this.fetch=Ct(r.fetch),this.lock=r.lock||gt,this.detectSessionInUrl=r.detectSessionInUrl,this.flowType=r.flowType,this.hasCustomAuthorizationHeader=r.hasCustomAuthorizationHeader,r.lock?this.lock=r.lock:R()&&(!((t=globalThis?.navigator)===null||t===void 0)&&t.locks)?this.lock=$r:this.lock=gt,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this)},this.persistSession?(r.storage?this.storage=r.storage:Rt()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=ft(this.memoryStorage)),r.userStorage&&(this.userStorage=r.userStorage)):(this.memoryStorage={},this.storage=ft(this.memoryStorage)),R()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(i){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",i)}(s=this.broadcastChannel)===null||s===void 0||s.addEventListener("message",async i=>{this._debug("received broadcast notification from other tab or client",i),await this._notifyAllSubscribers(i.data.event,i.data.session,!1)})}this.initialize()}get jwks(){var e,t;return(t=(e=ee[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){ee[this.storageKey]=Object.assign(Object.assign({},ee[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=ee[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){ee[this.storageKey]=Object.assign(Object.assign({},ee[this.storageKey]),{cachedAt:e})}_debug(...e){return this.logDebugMessages&&this.logger(`GoTrueClient@${this.instanceID} (${Pt}) ${new Date().toISOString()}`,...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{const t=nr(window.location.href);let s="none";if(this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce"),R()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(t,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),Vs(i)){const l=(e=i.details)===null||e===void 0?void 0:e.code;if(l==="identity_already_exists"||l==="identity_not_found"||l==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:o,redirectType:a}=r;return this._debug("#_initialize()","detected session in URL",o,"redirect type",a),await this._saveSession(o),setTimeout(async()=>{a==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return _(t)?{error:t}:{error:new At("Unexpected error during initialization",t)}}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:x}),{data:o,error:a}=i;if(a||!o)return{data:{user:null,session:null},error:a};const l=o.session,c=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(i){if(_(i))return{data:{user:null,session:null},error:i};throw i}}async signUp(e){var t,s,r;try{let i;if("email"in e){const{email:h,password:u,options:d}=e;let f=null,g=null;this.flowType==="pkce"&&([f,g]=await X(this.storage,this.storageKey)),i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:d?.emailRedirectTo,body:{email:h,password:u,data:(t=d?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:d?.captchaToken},code_challenge:f,code_challenge_method:g},xform:x})}else if("phone"in e){const{phone:h,password:u,options:d}=e;i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:h,password:u,data:(s=d?.data)!==null&&s!==void 0?s:{},channel:(r=d?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:d?.captchaToken}},xform:x})}else throw new pe("You must provide either an email or phone number and a password");const{data:o,error:a}=i;if(a||!o)return{data:{user:null,session:null},error:a};const l=o.session,c=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(i){if(_(i))return{data:{user:null,session:null},error:i};throw i}}async signInWithPassword(e){try{let t;if("email"in e){const{email:i,password:o,options:a}=e;t=await y(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:o,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:dt})}else if("phone"in e){const{phone:i,password:o,options:a}=e;t=await y(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:o,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:dt})}else throw new pe("You must provide either an email or phone number and a password");const{data:s,error:r}=t;return r?{data:{user:null,session:null},error:r}:!s||!s.session||!s.user?{data:{user:null,session:null},error:new ge}:(s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),{data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(_(t))return{data:{user:null,session:null},error:t};throw t}}async signInWithOAuth(e){var t,s,r,i;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;if(t==="solana")return await this.signInWithSolana(e);throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}async signInWithSolana(e){var t,s,r,i,o,a,l,c,h,u,d,f;let g,w;if("message"in e)g=e.message,w=e.signature;else{const{chain:v,wallet:k,statement:O,options:p}=e;let m;if(R())if(typeof k=="object")m=k;else{const E=window;if("solana"in E&&typeof E.solana=="object"&&("signIn"in E.solana&&typeof E.solana.signIn=="function"||"signMessage"in E.solana&&typeof E.solana.signMessage=="function"))m=E.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof k!="object"||!p?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");m=k}const S=new URL((t=p?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in m&&m.signIn){const E=await m.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},p?.signInWithSolana),{version:"1",domain:S.host,uri:S.href}),O?{statement:O}:null));let $;if(Array.isArray(E)&&E[0]&&typeof E[0]=="object")$=E[0];else if(E&&typeof E=="object"&&"signedMessage"in E&&"signature"in E)$=E;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in $&&"signature"in $&&(typeof $.signedMessage=="string"||$.signedMessage instanceof Uint8Array)&&$.signature instanceof Uint8Array)g=typeof $.signedMessage=="string"?$.signedMessage:new TextDecoder().decode($.signedMessage),w=$.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in m)||typeof m.signMessage!="function"||!("publicKey"in m)||typeof m!="object"||!m.publicKey||!("toBase58"in m.publicKey)||typeof m.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");g=[`${S.host} wants you to sign in with your Solana account:`,m.publicKey.toBase58(),...O?["",O,""]:[""],"Version: 1",`URI: ${S.href}`,`Issued At: ${(r=(s=p?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=p?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${p.signInWithSolana.notBefore}`]:[],...!((o=p?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${p.signInWithSolana.expirationTime}`]:[],...!((a=p?.signInWithSolana)===null||a===void 0)&&a.chainId?[`Chain ID: ${p.signInWithSolana.chainId}`]:[],...!((l=p?.signInWithSolana)===null||l===void 0)&&l.nonce?[`Nonce: ${p.signInWithSolana.nonce}`]:[],...!((c=p?.signInWithSolana)===null||c===void 0)&&c.requestId?[`Request ID: ${p.signInWithSolana.requestId}`]:[],...!((u=(h=p?.signInWithSolana)===null||h===void 0?void 0:h.resources)===null||u===void 0)&&u.length?["Resources",...p.signInWithSolana.resources.map($=>`- ${$}`)]:[]].join(`
./salon-light-plan/dist/assets 2/data-vendor-BeNRgWeM 2.js:  });`;class gs{constructor(e,t){var s;this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=bt,this.heartbeatIntervalMs=25e3,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=rt,this.ref=0,this.logger=rt,this.conn=null,this.sendBuffer=[],this.serializer=new os,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._resolveFetch=i=>{let o;return i?o=i:typeof fetch>"u"?o=(...a)=>ue(async()=>{const{default:l}=await Promise.resolve().then(()=>ie);return{default:l}},void 0).then(({default:l})=>l(...a)):o=fetch,(...a)=>o(...a)},this.endPoint=`${e}/${Oe.websocket}`,this.httpEndpoint=Et(e),t?.transport?this.transport=t.transport:this.transport=null,t?.params&&(this.params=t.params),t?.timeout&&(this.timeout=t.timeout),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),t?.heartbeatIntervalMs&&(this.heartbeatIntervalMs=t.heartbeatIntervalMs);const r=(s=t?.params)===null||s===void 0?void 0:s.apikey;if(r&&(this.accessTokenValue=r,this.apiKey=r),this.reconnectAfterMs=t?.reconnectAfterMs?t.reconnectAfterMs:i=>[1e3,2e3,5e3,1e4][i-1]||1e4,this.encode=t?.encode?t.encode:(i,o)=>o(JSON.stringify(i)),this.decode=t?.decode?t.decode:this.serializer.decode.bind(this.serializer),this.reconnectTimer=new kt(async()=>{this.disconnect(),this.connect()},this.reconnectAfterMs),this.fetch=this._resolveFetch(t?.fetch),t?.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.worker=t?.worker||!1,this.workerUrl=t?.workerUrl}this.accessToken=t?.accessToken||null}connect(){if(!this.conn){if(this.transport||(this.transport=ts),!this.transport)throw new Error("No transport provided");this.conn=new this.transport(this.endpointURL()),this.setupConnection()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:is}))}disconnect(e,t){this.conn&&(this.conn.onclose=function(){},e?this.conn.close(e,t??""):this.conn.close(),this.conn=null,this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.reset(),this.channels.forEach(s=>s.teardown()))}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case le.connecting:return W.Connecting;case le.open:return W.Open;case le.closing:return W.Closing;default:return W.Closed}}isConnected(){return this.connectionState()===W.Open}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new qe(`realtime:${e}`,t,this);return this.channels.push(i),i}}push(e){const{topic:t,event:s,payload:r,ref:i}=e,o=()=>{this.encode(e,a=>{var l;(l=this.conn)===null||l===void 0||l.send(a)})};this.log("push",`${t} ${s} (${i})`,r),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(e=null){let t=e||this.accessToken&&await this.accessToken()||this.accessTokenValue;this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(s=>{const r={access_token:t,version:rs};t&&s.updateJoinPayload(r),s.joinedOnce&&s._isJoined()&&s._push(C.access_token,{access_token:t})}))}async sendHeartbeat(){var e;if(!this.isConnected()){this.heartbeatCallback("disconnected");return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection"),this.heartbeatCallback("timeout"),(e=this.conn)===null||e===void 0||e.close(ns,"hearbeat timeout");return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef}),this.heartbeatCallback("sent"),await this.setAuth()}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}setupConnection(){this.conn&&(this.conn.binaryType="arraybuffer",this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e))}_onConnMessage(e){this.decode(e.data,t=>{let{topic:s,event:r,payload:i,ref:o}=t;s==="phoenix"&&r==="phx_reply"&&this.heartbeatCallback(t.payload.status=="ok"?"ok":"error"),o&&o===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null),this.log("receive",`${i.status||""} ${s} ${r} ${o&&"("+o+")"||""}`,i),Array.from(this.channels).filter(a=>a._isMember(s)).forEach(a=>a._trigger(r,i,o)),this.stateChangeCallbacks.message.forEach(a=>a(t))})}_onConnOpen(){this.log("transport",`connected to ${this.endpointURL()}`),this.flushSendBuffer(),this.reconnectTimer.reset(),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this.stateChangeCallbacks.open.forEach(e=>e())}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this.workerRef.terminate()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(e){this.log("transport","close",e),this._triggerChanError(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.scheduleTimeout(),this.stateChangeCallbacks.close.forEach(t=>t(e))}_onConnError(e){this.log("transport",`${e}`),this._triggerChanError(),this.stateChangeCallbacks.error.forEach(t=>t(e))}_triggerChanError(){this.channels.forEach(e=>e._trigger(C.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([fs],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}}class Be extends Error{constructor(e){super(e),this.__isStorageError=!0,this.name="StorageError"}}function j(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}class ps extends Be{constructor(e,t){super(e),this.name="StorageApiError",this.status=t}toJSON(){return{name:this.name,message:this.message,status:this.status}}}class $e extends Be{constructor(e,t){super(e),this.name="StorageUnknownError",this.originalError=t}}var vs=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const Tt=n=>{let e;return n?e=n:typeof fetch>"u"?e=(...t)=>ue(async()=>{const{default:s}=await Promise.resolve().then(()=>ie);return{default:s}},void 0).then(({default:s})=>s(...t)):e=fetch,(...t)=>e(...t)},_s=()=>vs(void 0,void 0,void 0,function*(){return typeof Response>"u"?(yield ue(()=>Promise.resolve().then(()=>ie),void 0)).Response:Response}),Re=n=>{if(Array.isArray(n))return n.map(t=>Re(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));e[r]=Re(s)}),e};var K=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const be=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),ws=(n,e,t)=>K(void 0,void 0,void 0,function*(){const s=yield _s();n instanceof s&&!t?.noResolveJson?n.json().then(r=>{e(new ps(be(r),n.status||500))}).catch(r=>{e(new $e(be(r),r))}):e(new $e(be(n),n))}),ys=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json"},e?.headers),s&&(r.body=JSON.stringify(s)),Object.assign(Object.assign({},r),t))};function de(n,e,t,s,r,i){return K(this,void 0,void 0,function*(){return new Promise((o,a)=>{n(t,ys(e,s,r,i)).then(l=>{if(!l.ok)throw l;return s?.noResolveJson?l:l.json()}).then(l=>o(l)).catch(l=>ws(l,a,s))})})}function _e(n,e,t,s){return K(this,void 0,void 0,function*(){return de(n,"GET",e,t,s)})}function D(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"POST",e,s,r,t)})}function ms(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"PUT",e,s,r,t)})}function bs(n,e,t,s){return K(this,void 0,void 0,function*(){return de(n,"HEAD",e,Object.assign(Object.assign({},t),{noResolveJson:!0}),s)})}function jt(n,e,t,s,r){return K(this,void 0,void 0,function*(){return de(n,"DELETE",e,s,r,t)})}var A=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const ks={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},it={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};class Ss{constructor(e,t={},s,r){this.url=e,this.headers=t,this.bucketId=s,this.fetch=Tt(r)}uploadOrUpdate(e,t,s,r){return A(this,void 0,void 0,function*(){try{let i;const o=Object.assign(Object.assign({},it),r);let a=Object.assign(Object.assign({},this.headers),e==="POST"&&{"x-upsert":String(o.upsert)});const l=o.metadata;typeof Blob<"u"&&s instanceof Blob?(i=new FormData,i.append("cacheControl",o.cacheControl),l&&i.append("metadata",this.encodeMetadata(l)),i.append("",s)):typeof FormData<"u"&&s instanceof FormData?(i=s,i.append("cacheControl",o.cacheControl),l&&i.append("metadata",this.encodeMetadata(l))):(i=s,a["cache-control"]=`max-age=${o.cacheControl}`,a["content-type"]=o.contentType,l&&(a["x-metadata"]=this.toBase64(this.encodeMetadata(l)))),r?.headers&&(a=Object.assign(Object.assign({},a),r.headers));const c=this._removeEmptyFolders(t),h=this._getFinalPath(c),u=yield this.fetch(`${this.url}/object/${h}`,Object.assign({method:e,body:i,headers:a},o?.duplex?{duplex:o.duplex}:{})),d=yield u.json();return u.ok?{data:{path:c,id:d.Id,fullPath:d.Key},error:null}:{data:null,error:d}}catch(i){if(j(i))return{data:null,error:i};throw i}})}upload(e,t,s){return A(this,void 0,void 0,function*(){return this.uploadOrUpdate("POST",e,t,s)})}uploadToSignedUrl(e,t,s,r){return A(this,void 0,void 0,function*(){const i=this._removeEmptyFolders(e),o=this._getFinalPath(i),a=new URL(this.url+`/object/upload/sign/${o}`);a.searchParams.set("token",t);try{let l;const c=Object.assign({upsert:it.upsert},r),h=Object.assign(Object.assign({},this.headers),{"x-upsert":String(c.upsert)});typeof Blob<"u"&&s instanceof Blob?(l=new FormData,l.append("cacheControl",c.cacheControl),l.append("",s)):typeof FormData<"u"&&s instanceof FormData?(l=s,l.append("cacheControl",c.cacheControl)):(l=s,h["cache-control"]=`max-age=${c.cacheControl}`,h["content-type"]=c.contentType);const u=yield this.fetch(a.toString(),{method:"PUT",body:l,headers:h}),d=yield u.json();return u.ok?{data:{path:i,fullPath:d.Key},error:null}:{data:null,error:d}}catch(l){if(j(l))return{data:null,error:l};throw l}})}createSignedUploadUrl(e,t){return A(this,void 0,void 0,function*(){try{let s=this._getFinalPath(e);const r=Object.assign({},this.headers);t?.upsert&&(r["x-upsert"]="true");const i=yield D(this.fetch,`${this.url}/object/upload/sign/${s}`,{},{headers:r}),o=new URL(this.url+i.url),a=o.searchParams.get("token");if(!a)throw new Be("No token returned by API");return{data:{signedUrl:o.toString(),path:e,token:a},error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}update(e,t,s){return A(this,void 0,void 0,function*(){return this.uploadOrUpdate("PUT",e,t,s)})}move(e,t,s){return A(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:e,destinationKey:t,destinationBucket:s?.destinationBucket},{headers:this.headers}),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}copy(e,t,s){return A(this,void 0,void 0,function*(){try{return{data:{path:(yield D(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:e,destinationKey:t,destinationBucket:s?.destinationBucket},{headers:this.headers})).Key},error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}createSignedUrl(e,t,s){return A(this,void 0,void 0,function*(){try{let r=this._getFinalPath(e),i=yield D(this.fetch,`${this.url}/object/sign/${r}`,Object.assign({expiresIn:t},s?.transform?{transform:s.transform}:{}),{headers:this.headers});const o=s?.download?`&download=${s.download===!0?"":s.download}`:"";return i={signedUrl:encodeURI(`${this.url}${i.signedURL}${o}`)},{data:i,error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}createSignedUrls(e,t,s){return A(this,void 0,void 0,function*(){try{const r=yield D(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn:t,paths:e},{headers:this.headers}),i=s?.download?`&download=${s.download===!0?"":s.download}`:"";return{data:r.map(o=>Object.assign(Object.assign({},o),{signedUrl:o.signedURL?encodeURI(`${this.url}${o.signedURL}${i}`):null})),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}download(e,t){return A(this,void 0,void 0,function*(){const r=typeof t?.transform<"u"?"render/image/authenticated":"object",i=this.transformOptsToQueryString(t?.transform||{}),o=i?`?${i}`:"";try{const a=this._getFinalPath(e);return{data:yield(yield _e(this.fetch,`${this.url}/${r}/${a}${o}`,{headers:this.headers,noResolveJson:!0})).blob(),error:null}}catch(a){if(j(a))return{data:null,error:a};throw a}})}info(e){return A(this,void 0,void 0,function*(){const t=this._getFinalPath(e);try{const s=yield _e(this.fetch,`${this.url}/object/info/${t}`,{headers:this.headers});return{data:Re(s),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}exists(e){return A(this,void 0,void 0,function*(){const t=this._getFinalPath(e);try{return yield bs(this.fetch,`${this.url}/object/${t}`,{headers:this.headers}),{data:!0,error:null}}catch(s){if(j(s)&&s instanceof $e){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}})}getPublicUrl(e,t){const s=this._getFinalPath(e),r=[],i=t?.download?`download=${t.download===!0?"":t.download}`:"";i!==""&&r.push(i);const a=typeof t?.transform<"u"?"render/image":"object",l=this.transformOptsToQueryString(t?.transform||{});l!==""&&r.push(l);let c=r.join("&");return c!==""&&(c=`?${c}`),{data:{publicUrl:encodeURI(`${this.url}/${a}/public/${s}${c}`)}}}remove(e){return A(this,void 0,void 0,function*(){try{return{data:yield jt(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:e},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}list(e,t,s){return A(this,void 0,void 0,function*(){try{const r=Object.assign(Object.assign(Object.assign({},ks),t),{prefix:e||""});return{data:yield D(this.fetch,`${this.url}/object/list/${this.bucketId}`,r,{headers:this.headers},s),error:null}}catch(r){if(j(r))return{data:null,error:r};throw r}})}encodeMetadata(e){return JSON.stringify(e)}toBase64(e){return typeof Buffer<"u"?Buffer.from(e).toString("base64"):btoa(e)}_getFinalPath(e){return`${this.bucketId}/${e}`}_removeEmptyFolders(e){return e.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(e){const t=[];return e.width&&t.push(`width=${e.width}`),e.height&&t.push(`height=${e.height}`),e.resize&&t.push(`resize=${e.resize}`),e.format&&t.push(`format=${e.format}`),e.quality&&t.push(`quality=${e.quality}`),t.join("&")}}const Es="2.7.1",Ts={"X-Client-Info":`storage-js/${Es}`};var Q=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,[])).next())})};class js{constructor(e,t={},s){this.url=e,this.headers=Object.assign(Object.assign({},Ts),t),this.fetch=Tt(s)}listBuckets(){return Q(this,void 0,void 0,function*(){try{return{data:yield _e(this.fetch,`${this.url}/bucket`,{headers:this.headers}),error:null}}catch(e){if(j(e))return{data:null,error:e};throw e}})}getBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield _e(this.fetch,`${this.url}/bucket/${e}`,{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}createBucket(e,t={public:!1}){return Q(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/bucket`,{id:e,name:e,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:this.headers}),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}updateBucket(e,t){return Q(this,void 0,void 0,function*(){try{return{data:yield ms(this.fetch,`${this.url}/bucket/${e}`,{id:e,name:e,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:this.headers}),error:null}}catch(s){if(j(s))return{data:null,error:s};throw s}})}emptyBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield D(this.fetch,`${this.url}/bucket/${e}/empty`,{},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}deleteBucket(e){return Q(this,void 0,void 0,function*(){try{return{data:yield jt(this.fetch,`${this.url}/bucket/${e}`,{},{headers:this.headers}),error:null}}catch(t){if(j(t))return{data:null,error:t};throw t}})}}class Ps extends js{constructor(e,t={},s){super(e,t,s)}from(e){return new Ss(this.url,this.headers,e,this.fetch)}}const Os="2.52.1";let ae="";typeof Deno<"u"?ae="deno":typeof document<"u"?ae="web":typeof navigator<"u"&&navigator.product==="ReactNative"?ae="react-native":ae="node";const As={"X-Client-Info":`supabase-js-${ae}/${Os}`},$s={headers:As},Rs={schema:"public"},Cs={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},xs={};var Is=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,e||[])).next())})};const Us=n=>{let e;return n?e=n:typeof fetch>"u"?e=pt:e=fetch,(...t)=>e(...t)},Ls=()=>typeof Headers>"u"?vt:Headers,Ds=(n,e,t)=>{const s=Us(t),r=Ls();return(i,o)=>Is(void 0,void 0,void 0,function*(){var a;const l=(a=yield e())!==null&&a!==void 0?a:n;let c=new r(o?.headers);return c.has("apikey")||c.set("apikey",n),c.has("Authorization")||c.set("Authorization",`Bearer ${l}`),s(i,Object.assign(Object.assign({},o),{headers:c}))})};var qs=function(n,e,t,s){function r(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(h){try{c(s.next(h))}catch(u){o(u)}}function l(h){try{c(s.throw(h))}catch(u){o(u)}}function c(h){h.done?i(h.value):r(h.value).then(a,l)}c((s=s.apply(n,[])).next())})};function Bs(n){return n.endsWith("/")?n:n+"/"}function Ns(n,e){var t,s;const{db:r,auth:i,realtime:o,global:a}=n,{db:l,auth:c,realtime:h,global:u}=e,d={db:Object.assign(Object.assign({},l),r),auth:Object.assign(Object.assign({},c),i),realtime:Object.assign(Object.assign({},h),o),global:Object.assign(Object.assign(Object.assign({},u),a),{headers:Object.assign(Object.assign({},(t=u?.headers)!==null&&t!==void 0?t:{}),(s=a?.headers)!==null&&s!==void 0?s:{})}),accessToken:()=>qs(this,void 0,void 0,function*(){return""})};return n.accessToken?d.accessToken=n.accessToken:delete d.accessToken,d}const Pt="2.71.1",te=30*1e3,Ce=3,ke=Ce*te,Ms="http://localhost:9999",Fs="supabase.auth.token",Ws={"X-Client-Info":`gotrue-js/${Pt}`},xe="X-Supabase-Api-Version",Ot={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},Ks=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,zs=600*1e3;class Ne extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function _(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class Js extends Ne{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function Hs(n){return _(n)&&n.name==="AuthApiError"}class At extends Ne{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class B extends Ne{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class L extends B{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function Gs(n){return _(n)&&n.name==="AuthSessionMissingError"}class ge extends B{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class pe extends B{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class ve extends B{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function Vs(n){return _(n)&&n.name==="AuthImplicitGrantRedirectError"}class nt extends B{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class Ie extends B{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function Se(n){return _(n)&&n.name==="AuthRetryableFetchError"}class ot extends B{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class Ue extends B{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const we="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),at=` 	
./salon-light-plan/dist/assets 2/data-vendor-BeNRgWeM 2.js:\r=`.split(""),Qs=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<at.length;e+=1)n[at[e].charCodeAt(0)]=-2;for(let e=0;e<we.length;e+=1)n[we[e].charCodeAt(0)]=e;return n})();function lt(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(we[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(we[s]),e.queuedBits-=6}}function $t(n,e,t){const s=Qs[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function ct(n){const e=[],t=o=>{e.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=o=>{Zs(o,s,t)};for(let o=0;o<n.length;o+=1)$t(n.charCodeAt(o),r,i);return e.join("")}function Xs(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function Ys(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}Xs(s,e)}}function Zs(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function er(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)$t(n.charCodeAt(r),t,s);return new Uint8Array(e)}function tr(n){const e=[];return Ys(n,t=>e.push(t)),new Uint8Array(e)}function sr(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>lt(r,t,s)),lt(null,t,s),e.join("")}function rr(n){return Math.round(Date.now()/1e3)+n}function ir(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(n){const e=Math.random()*16|0;return(n=="x"?e:e&3|8).toString(16)})}const R=()=>typeof window<"u"&&typeof document<"u",N={tested:!1,writable:!1},Rt=()=>{if(!R())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(N.tested)return N.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),N.tested=!0,N.writable=!0}catch{N.tested=!0,N.writable=!1}return N.writable};function nr(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,i)=>{e[i]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const Ct=n=>{let e;return n?e=n:typeof fetch>"u"?e=(...t)=>ue(async()=>{const{default:s}=await Promise.resolve().then(()=>ie);return{default:s}},void 0).then(({default:s})=>s(...t)):e=fetch,(...t)=>e(...t)},or=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",se=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},M=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},U=async(n,e)=>{await n.removeItem(e)};class ye{constructor(){this.promise=new ye.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}ye.promiseConstructor=Promise;function Ee(n){const e=n.split(".");if(e.length!==3)throw new Ue("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!Ks.test(e[s]))throw new Ue("JWT not in base64url format");return{header:JSON.parse(ct(e[0])),payload:JSON.parse(ct(e[1])),signature:er(e[2]),raw:{header:e[0],payload:e[1]}}}async function ar(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function lr(n,e){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const o=await n(i);if(!e(i,null,o)){s(o);return}}catch(o){if(!e(i,o)){r(o);return}}})()})}function cr(n){return("0"+n.toString(16)).substr(-2)}function hr(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let i=0;i<56;i++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,cr).join("")}async function ur(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function dr(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await ur(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function X(n,e,t=!1){const s=hr();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await se(n,`${e}-code-verifier`,r);const i=await dr(s);return[i,s===i?"plain":"s256"]}const fr=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function gr(n){const e=n.headers.get(xe);if(!e||!e.match(fr))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function pr(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function vr(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const _r=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function Y(n){if(!_r.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function Te(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function ht(n){return JSON.parse(JSON.stringify(n))}var wr=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};const F=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),yr=[502,503,504];async function ut(n){var e;if(!or(n))throw new Ie(F(n),0);if(yr.includes(n.status))throw new Ie(F(n),n.status);let t;try{t=await n.json()}catch(i){throw new At(F(i),i)}let s;const r=gr(n);if(r&&r.getTime()>=Ot["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new ot(F(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new L}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((i,o)=>i&&typeof o=="string",!0))throw new ot(F(t),n.status,t.weak_password.reasons);throw new Js(F(t),n.status||500,s)}const mr=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function y(n,e,t,s){var r;const i=Object.assign({},s?.headers);i[xe]||(i[xe]=Ot["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const o=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const a=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",l=await br(n,e,t+a,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(l):{data:Object.assign({},l),error:null}}async function br(n,e,t,s,r,i){const o=mr(e,s,r,i);let a;try{a=await n(t,Object.assign({},o))}catch(l){throw console.error(l),new Ie(F(l),0)}if(a.ok||await ut(a),s?.noResolveJson)return a;try{return await a.json()}catch(l){await ut(l)}}function x(n){var e;let t=null;Tr(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=rr(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function dt(n){const e=x(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function q(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function kr(n){return{data:n,error:null}}function Sr(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i}=n,o=wr(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),a={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i},l=Object.assign({},o);return{data:{properties:a,user:l},error:null}}function Er(n){return n}function Tr(n){return n.access_token&&n.refresh_token&&n.expires_in}const je=["global","local","others"];var jr=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class Pr{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=Ct(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)}}async signOut(e,t=je[0]){if(je.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${je.join(", ")}`);try{return await y(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(_(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await y(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=jr(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await y(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:Sr,redirectTo:t?.redirectTo})}catch(t){if(_(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await y(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:q})}catch(t){if(_(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,i,o,a,l;try{const c={nextPage:null,lastPage:0,total:0},h=await y(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:Er});if(h.error)throw h.error;const u=await h.json(),d=(o=h.headers.get("x-total-count"))!==null&&o!==void 0?o:0,f=(l=(a=h.headers.get("link"))===null||a===void 0?void 0:a.split(","))!==null&&l!==void 0?l:[];return f.length>0&&(f.forEach(g=>{const w=parseInt(g.split(";")[0].split("=")[1].substring(0,1)),v=JSON.parse(g.split(";")[1].split("=")[1]);c[`${v}Page`]=w}),c.total=parseInt(d)),{data:Object.assign(Object.assign({},u),c),error:null}}catch(c){if(_(c))return{data:{users:[]},error:c};throw c}}async getUserById(e){Y(e);try{return await y(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:q})}catch(t){if(_(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){Y(e);try{return await y(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){Y(e);try{return await y(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:q})}catch(s){if(_(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){Y(e.userId);try{const{data:t,error:s}=await y(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(_(t))return{data:null,error:t};throw t}}async _deleteFactor(e){Y(e.userId),Y(e.id);try{return{data:await y(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(_(t))return{data:null,error:t};throw t}}}function ft(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}function Or(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}const Z={debug:!!(globalThis&&Rt()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class xt extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class Ar extends xt{}async function $r(n,e,t){Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),Z.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw Z.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new Ar(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(Z.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}Or();const Rr={url:Ms,storageKey:Fs,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:Ws,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1};async function gt(n,e,t){return await t()}const ee={};class he{constructor(e){var t,s;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log,this.instanceID=he.nextInstanceID,he.nextInstanceID+=1,this.instanceID>0&&R()&&console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");const r=Object.assign(Object.assign({},Rr),e);if(this.logDebugMessages=!!r.debug,typeof r.debug=="function"&&(this.logger=r.debug),this.persistSession=r.persistSession,this.storageKey=r.storageKey,this.autoRefreshToken=r.autoRefreshToken,this.admin=new Pr({url:r.url,headers:r.headers,fetch:r.fetch}),this.url=r.url,this.headers=r.headers,this.fetch=Ct(r.fetch),this.lock=r.lock||gt,this.detectSessionInUrl=r.detectSessionInUrl,this.flowType=r.flowType,this.hasCustomAuthorizationHeader=r.hasCustomAuthorizationHeader,r.lock?this.lock=r.lock:R()&&(!((t=globalThis?.navigator)===null||t===void 0)&&t.locks)?this.lock=$r:this.lock=gt,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this)},this.persistSession?(r.storage?this.storage=r.storage:Rt()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=ft(this.memoryStorage)),r.userStorage&&(this.userStorage=r.userStorage)):(this.memoryStorage={},this.storage=ft(this.memoryStorage)),R()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(i){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",i)}(s=this.broadcastChannel)===null||s===void 0||s.addEventListener("message",async i=>{this._debug("received broadcast notification from other tab or client",i),await this._notifyAllSubscribers(i.data.event,i.data.session,!1)})}this.initialize()}get jwks(){var e,t;return(t=(e=ee[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){ee[this.storageKey]=Object.assign(Object.assign({},ee[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=ee[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){ee[this.storageKey]=Object.assign(Object.assign({},ee[this.storageKey]),{cachedAt:e})}_debug(...e){return this.logDebugMessages&&this.logger(`GoTrueClient@${this.instanceID} (${Pt}) ${new Date().toISOString()}`,...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{const t=nr(window.location.href);let s="none";if(this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce"),R()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(t,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),Vs(i)){const l=(e=i.details)===null||e===void 0?void 0:e.code;if(l==="identity_already_exists"||l==="identity_not_found"||l==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:o,redirectType:a}=r;return this._debug("#_initialize()","detected session in URL",o,"redirect type",a),await this._saveSession(o),setTimeout(async()=>{a==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return _(t)?{error:t}:{error:new At("Unexpected error during initialization",t)}}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:x}),{data:o,error:a}=i;if(a||!o)return{data:{user:null,session:null},error:a};const l=o.session,c=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(i){if(_(i))return{data:{user:null,session:null},error:i};throw i}}async signUp(e){var t,s,r;try{let i;if("email"in e){const{email:h,password:u,options:d}=e;let f=null,g=null;this.flowType==="pkce"&&([f,g]=await X(this.storage,this.storageKey)),i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:d?.emailRedirectTo,body:{email:h,password:u,data:(t=d?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:d?.captchaToken},code_challenge:f,code_challenge_method:g},xform:x})}else if("phone"in e){const{phone:h,password:u,options:d}=e;i=await y(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:h,password:u,data:(s=d?.data)!==null&&s!==void 0?s:{},channel:(r=d?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:d?.captchaToken}},xform:x})}else throw new pe("You must provide either an email or phone number and a password");const{data:o,error:a}=i;if(a||!o)return{data:{user:null,session:null},error:a};const l=o.session,c=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",l)),{data:{user:c,session:l},error:null}}catch(i){if(_(i))return{data:{user:null,session:null},error:i};throw i}}async signInWithPassword(e){try{let t;if("email"in e){const{email:i,password:o,options:a}=e;t=await y(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:o,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:dt})}else if("phone"in e){const{phone:i,password:o,options:a}=e;t=await y(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:o,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:dt})}else throw new pe("You must provide either an email or phone number and a password");const{data:s,error:r}=t;return r?{data:{user:null,session:null},error:r}:!s||!s.session||!s.user?{data:{user:null,session:null},error:new ge}:(s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),{data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(_(t))return{data:{user:null,session:null},error:t};throw t}}async signInWithOAuth(e){var t,s,r,i;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;if(t==="solana")return await this.signInWithSolana(e);throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}async signInWithSolana(e){var t,s,r,i,o,a,l,c,h,u,d,f;let g,w;if("message"in e)g=e.message,w=e.signature;else{const{chain:v,wallet:k,statement:O,options:p}=e;let m;if(R())if(typeof k=="object")m=k;else{const E=window;if("solana"in E&&typeof E.solana=="object"&&("signIn"in E.solana&&typeof E.solana.signIn=="function"||"signMessage"in E.solana&&typeof E.solana.signMessage=="function"))m=E.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof k!="object"||!p?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");m=k}const S=new URL((t=p?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in m&&m.signIn){const E=await m.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},p?.signInWithSolana),{version:"1",domain:S.host,uri:S.href}),O?{statement:O}:null));let $;if(Array.isArray(E)&&E[0]&&typeof E[0]=="object")$=E[0];else if(E&&typeof E=="object"&&"signedMessage"in E&&"signature"in E)$=E;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in $&&"signature"in $&&(typeof $.signedMessage=="string"||$.signedMessage instanceof Uint8Array)&&$.signature instanceof Uint8Array)g=typeof $.signedMessage=="string"?$.signedMessage:new TextDecoder().decode($.signedMessage),w=$.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in m)||typeof m.signMessage!="function"||!("publicKey"in m)||typeof m!="object"||!m.publicKey||!("toBase58"in m.publicKey)||typeof m.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");g=[`${S.host} wants you to sign in with your Solana account:`,m.publicKey.toBase58(),...O?["",O,""]:[""],"Version: 1",`URI: ${S.href}`,`Issued At: ${(r=(s=p?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=p?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${p.signInWithSolana.notBefore}`]:[],...!((o=p?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${p.signInWithSolana.expirationTime}`]:[],...!((a=p?.signInWithSolana)===null||a===void 0)&&a.chainId?[`Chain ID: ${p.signInWithSolana.chainId}`]:[],...!((l=p?.signInWithSolana)===null||l===void 0)&&l.nonce?[`Nonce: ${p.signInWithSolana.nonce}`]:[],...!((c=p?.signInWithSolana)===null||c===void 0)&&c.requestId?[`Request ID: ${p.signInWithSolana.requestId}`]:[],...!((u=(h=p?.signInWithSolana)===null||h===void 0?void 0:h.resources)===null||u===void 0)&&u.length?["Resources",...p.signInWithSolana.resources.map($=>`- ${$}`)]:[]].join(`
./salon-light-plan/src/middleware/security.ts:export function validatePasswordStrength(password: string): {
./salon-light-plan/src/middleware/security.ts:  if (password.length < 8) {
./salon-light-plan/src/middleware/security.ts:  if (!/[a-z]/.test(password)) {
./salon-light-plan/src/middleware/security.ts:  if (!/[A-Z]/.test(password)) {
./salon-light-plan/src/middleware/security.ts:  if (!/[0-9]/.test(password)) {
./salon-light-plan/src/middleware/security.ts:  if (!/[^a-zA-Z0-9]/.test(password)) {
./salon-light-plan/src/middleware/security 2.ts:export function validatePasswordStrength(password: string): {
./salon-light-plan/src/middleware/security 2.ts:  if (password.length < 8) {
./salon-light-plan/src/middleware/security 2.ts:  if (!/[a-z]/.test(password)) {
./salon-light-plan/src/middleware/security 2.ts:  if (!/[A-Z]/.test(password)) {
./salon-light-plan/src/middleware/security 2.ts:  if (!/[0-9]/.test(password)) {
./salon-light-plan/src/middleware/security 2.ts:  if (!/[^a-zA-Z0-9]/.test(password)) {
./salon-light-plan/src/types/auth.ts:  login: (email: string, password: string) => Promise<void>;
./salon-light-plan/src/types/auth.ts:  signup: (email: string, password: string, tenantName: string) => Promise<void>;
./salon-light-plan/src/contexts/MockAuthContext 2.tsx:  const signIn = async (email: string, password: string) => {
./salon-light-plan/src/contexts/MockAuthContext 2.tsx:  const signUp = async (email: string, password: string, tenantName: string) => {
./salon-light-plan/src/contexts/AuthContextSafe.tsx:  const login = async (email: string, password: string) => {
./salon-light-plan/src/contexts/AuthContextSafe.tsx:      const data = await supabaseAuth.signIn(email, password);
./salon-light-plan/src/contexts/AuthContextSafe.tsx:    password: string,
./salon-light-plan/src/contexts/AuthContextSafe.tsx:      const data = await supabaseAuth.signUp(email, password, tenantName);
./salon-light-plan/src/contexts/AuthContext.tsx:  const login = async (email: string, password: string) => {
./salon-light-plan/src/contexts/AuthContext.tsx:      const data = await supabaseAuth.signIn(email, password);
./salon-light-plan/src/contexts/AuthContext.tsx:  const signup = async (email: string, password: string, tenantName: string) => {
./salon-light-plan/src/contexts/AuthContext.tsx:      const data = await supabaseAuth.signUp(email, password, tenantName);
./salon-light-plan/src/contexts/MockAuthContext.tsx:  const signIn = async (email: string, password: string) => {
./salon-light-plan/src/contexts/MockAuthContext.tsx:  const signUp = async (email: string, password: string, tenantName: string) => {
./salon-light-plan/src/utils/validation.ts:  if (!password || password.length === 0) {
./salon-light-plan/src/utils/validation.ts:  const strengthCheck = validatePasswordStrength(password);
./salon-light-plan/src/utils/validation.ts:    sanitizedValue: password // パスワードはサニタイズしない
./salon-light-plan/src/utils/validation 2.ts:  if (!password || password.length === 0) {
./salon-light-plan/src/utils/validation 2.ts:  const strengthCheck = validatePasswordStrength(password);
./salon-light-plan/src/utils/validation 2.ts:    sanitizedValue: password // パスワードはサニタイズしない
./salon-light-plan/src/components/auth/LoginForm.tsx:  const [password, setPassword] = useState('');
./salon-light-plan/src/components/auth/LoginForm.tsx:        await signIn(email, password);
./salon-light-plan/src/components/auth/LoginForm.tsx:              <label htmlFor="password" className="sr-only">
./salon-light-plan/src/components/auth/LoginForm.tsx:                  id="password"
./salon-light-plan/src/components/auth/LoginForm.tsx:                  name="password"
./salon-light-plan/src/components/auth/LoginForm.tsx:                  type="password"
./salon-light-plan/src/components/auth/LoginForm.tsx:                  autoComplete="current-password"
./salon-light-plan/src/components/auth/LoginForm.tsx:                  value={password}
./salon-light-plan/src/components/auth/LoginForm.tsx:                to="/forgot-password"
./salon-light-plan/src/components/auth/SignupForm.tsx:  const [password, setPassword] = useState('');
./salon-light-plan/src/components/auth/SignupForm.tsx:    if (password !== confirmPassword) {
./salon-light-plan/src/components/auth/SignupForm.tsx:    if (password.length < 6) {
./salon-light-plan/src/components/auth/SignupForm.tsx:      await signUp(email, password, tenantName);
./salon-light-plan/src/components/auth/SignupForm.tsx:              <label htmlFor="password" className="sr-only">
./salon-light-plan/src/components/auth/SignupForm.tsx:                  id="password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  name="password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  type="password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  autoComplete="new-password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  value={password}
./salon-light-plan/src/components/auth/SignupForm.tsx:              <label htmlFor="confirm-password" className="sr-only">
./salon-light-plan/src/components/auth/SignupForm.tsx:                  id="confirm-password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  type="password"
./salon-light-plan/src/components/auth/SignupForm.tsx:                  autoComplete="new-password"
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelAccessToken: 'test-token',
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelSecret: 'test-secret',
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelAccessToken: 'test-token',
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelSecret: 'test-secret',
./salon-light-plan/src/__tests__/integration.test 2.ts:        replyToken: 'reply-token-123',
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelAccessToken: 'invalid-token',
./salon-light-plan/src/__tests__/integration.test 2.ts:        channelSecret: 'invalid-secret',
./salon-light-plan/src/__tests__/integration.test.ts:        channelAccessToken: 'test-token',
./salon-light-plan/src/__tests__/integration.test.ts:        channelSecret: 'test-secret',
./salon-light-plan/src/__tests__/integration.test.ts:        channelAccessToken: 'test-token',
./salon-light-plan/src/__tests__/integration.test.ts:        channelSecret: 'test-secret',
./salon-light-plan/src/__tests__/integration.test.ts:        replyToken: 'reply-token-123',
./salon-light-plan/src/__tests__/integration.test.ts:        channelAccessToken: 'invalid-token',
./salon-light-plan/src/__tests__/integration.test.ts:        channelSecret: 'invalid-secret',
./salon-light-plan/src/lib/supabase.ts:  signIn: async (email: string, password: string) => {
./salon-light-plan/src/lib/supabase.ts:      password,
./salon-light-plan/src/lib/supabase.ts:  signUp: async (email: string, password: string, tenantName: string) => {
./salon-light-plan/src/lib/supabase.ts:        password,
./salon-light-plan/src/lib/supabase-safe.ts:  signIn: async (email: string, password: string) => {
./salon-light-plan/src/lib/supabase-safe.ts:      password,
./salon-light-plan/src/lib/supabase-safe.ts:  signUp: async (email: string, password: string, tenantName: string) => {
./salon-light-plan/src/lib/supabase-safe.ts:        password,
./scripts/init-db.js:          password: 'password123',
./scripts/init-db.js:        logger.info('Password: password123');
./api/index.js:      password: '$2a$10$KXRIhgI2GLZ5TEGEtOVTP.sRlL9.DPqu0VphowBqE1lxYDrY.3ruC', // password: admin123
./api/index.js:  const token = authHeader && authHeader.split(' ')[1];
./api/index.js:  if (!token) {
./api/index.js:  jwt.verify(token, JWT_SECRET, (err, user) => {
./api/index.js:      return res.status(403).json({ error: 'Invalid token' });
./api/index.js:  const { email, password } = req.body;
./api/index.js:  const validPassword = await bcrypt.compare(password, user.password);
./api/index.js:  const token = jwt.sign(
./api/index.js:    token,
./src/middleware/authMiddleware.js: * Authentication middleware to verify JWT token
./src/middleware/authMiddleware.js:    const token = authHeader && authHeader.startsWith('Bearer ') 
./src/middleware/authMiddleware.js:    if (!token) {
./src/middleware/authMiddleware.js:    const decoded = verifyToken(token);
./src/middleware/authMiddleware.js:      error: 'Invalid or expired token',
./src/middleware/authMiddleware.js: * Optional authentication middleware - doesn't fail if no token
./src/middleware/authMiddleware.js:    const token = authHeader && authHeader.startsWith('Bearer ') 
./src/middleware/authMiddleware.js:    if (token) {
./src/middleware/authMiddleware.js:      const decoded = verifyToken(token);
./src/middleware/auth-new.js:    const token = req.header('Authorization')?.replace('Bearer ', '');
./src/middleware/auth-new.js:    if (!token) {
./src/middleware/auth-new.js:    req.token = token;
./src/middleware/errorMiddleware.js:    message = 'Invalid token';
./src/middleware/auth.js:  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
./src/middleware/auth.js:  if (!token) {
./src/middleware/auth.js:  jwt.verify(token, config.jwt.secret, (err, user) => {
./src/middleware/auth.js:        error: 'Invalid or expired token'
./src/frontend/app.prod.js:        this.token = localStorage.getItem('sms_token');
./src/frontend/app.prod.js:        if (window.location.hash && window.location.hash.includes('access_token')) {
./src/frontend/app.prod.js:        if (!this.token && window.location.pathname !== '/login') {
./src/frontend/app.prod.js:        if (this.token) {
./src/frontend/app.prod.js:                        'Authorization': `Bearer ${this.token}`
./src/frontend/app.prod.js:                    localStorage.removeItem('sms_token');
./src/frontend/app.prod.js:                'Authorization': `Bearer ${this.token}`
./src/frontend/app.prod.js:                localStorage.removeItem('sms_token');
./src/frontend/app.prod.js:        const password = document.getElementById('password').value;
./src/frontend/app.prod.js:                body: JSON.stringify({ email, password })
./src/frontend/app.prod.js:            localStorage.setItem('sms_token', data.accessToken);
./src/frontend/app.js:        this.token = localStorage.getItem('sms_token');
./src/frontend/app.js:        if (!this.token && window.location.pathname !== '/login') {
./src/frontend/app.js:        if (this.token) {
./src/frontend/app.js:                        'Authorization': `Bearer ${this.token}`
./src/frontend/app.js:                    localStorage.removeItem('sms_token');
./src/frontend/app.js:                'Authorization': `Bearer ${this.token}`
./src/frontend/app.js:                localStorage.removeItem('sms_token');
./src/frontend/app.js:        const password = document.getElementById('password').value;
./src/frontend/app.js:                body: JSON.stringify({ email, password })
./src/frontend/app.js:            localStorage.setItem('sms_token', data.token);
./src/auth/jwt.js: * Generate JWT token for user
./src/auth/jwt.js: * @returns {string} JWT token
./src/auth/jwt.js: * Verify JWT token
./src/auth/jwt.js: * @param {string} token - JWT token to verify
./src/auth/jwt.js: * @returns {Object} Decoded token payload
./src/auth/jwt.js: * @throws {Error} If token is invalid
./src/auth/jwt.js:const verifyToken = (token) => {
./src/auth/jwt.js:    return jwt.verify(token, JWT_SECRET, {
./src/auth/jwt.js:    throw new Error('Invalid or expired token');
./src/auth/jwt.js: * Decode JWT token without verification (for expired token info)
./src/auth/jwt.js: * @param {string} token - JWT token to decode
./src/auth/jwt.js: * @returns {Object} Decoded token payload
./src/auth/jwt.js:const decodeToken = (token) => {
./src/auth/jwt.js:  return jwt.decode(token);
./src/auth/jwt.js: * Generate refresh token
./src/auth/jwt.js: * @returns {string} Refresh token
./src/auth/bcrypt.js: * Hash password using bcrypt
./src/auth/bcrypt.js: * @param {string} password - Plain text password
./src/auth/bcrypt.js: * @returns {Promise<string>} Hashed password
./src/auth/bcrypt.js:const hashPassword = async (password) => {
./src/auth/bcrypt.js:    return await bcrypt.hash(password, salt);
./src/auth/bcrypt.js:    throw new Error('Error hashing password');
./src/auth/bcrypt.js: * Compare password with hash
./src/auth/bcrypt.js: * @param {string} password - Plain text password
./src/auth/bcrypt.js: * @param {string} hash - Hashed password
./src/auth/bcrypt.js: * @returns {Promise<boolean>} True if password matches
./src/auth/bcrypt.js:const comparePassword = async (password, hash) => {
./src/auth/bcrypt.js:    return await bcrypt.compare(password, hash);
./src/auth/bcrypt.js:    throw new Error('Error comparing password');
./src/auth/bcrypt.js: * Validate password strength
./src/auth/bcrypt.js: * @param {string} password - Password to validate
./src/auth/bcrypt.js:const validatePassword = (password) => {
./src/auth/bcrypt.js:  const hasUpperCase = /[A-Z]/.test(password);
./src/auth/bcrypt.js:  const hasLowerCase = /[a-z]/.test(password);
./src/auth/bcrypt.js:  const hasNumbers = /\d/.test(password);
./src/auth/bcrypt.js:  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
./src/auth/bcrypt.js:  if (password.length < minLength) {
./src/auth/bcrypt.js:    strength: calculatePasswordStrength(password)
./src/auth/bcrypt.js: * Calculate password strength score
./src/auth/bcrypt.js: * @param {string} password - Password to evaluate
./src/auth/bcrypt.js:const calculatePasswordStrength = (password) => {
./src/auth/bcrypt.js:  if (password.length >= 8) score += 1;
./src/auth/bcrypt.js:  if (password.length >= 12) score += 1;
./src/auth/bcrypt.js:  if (/[a-z]/.test(password)) score += 1;
./src/auth/bcrypt.js:  if (/[A-Z]/.test(password)) score += 1;
./src/auth/bcrypt.js:  if (/\d/.test(password)) score += 1;
./src/auth/bcrypt.js:  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) score += 1;
./src/backend/server.js:      password: '$2a$10$kFVBZMghl0Y4dGz1ktSjXOmGawrEj3SJZQqcXKxOvvGzFBKu1Qjmq', // password: admin123
./src/backend/server.js:const JWT_SECRET = 'your-secret-key-change-in-production';
./src/backend/server.js:  const token = authHeader && authHeader.split(' ')[1];
./src/backend/server.js:  if (!token) {
./src/backend/server.js:  jwt.verify(token, JWT_SECRET, (err, user) => {
./src/backend/server.js:      return res.status(403).json({ error: 'Invalid token' });
./src/backend/server.js:  const { email, password } = req.body;
./src/backend/server.js:  const validPassword = await bcrypt.compare(password, user.password);
./src/backend/server.js:  const token = jwt.sign(
./src/backend/server.js:    token,
./src/models/User.js:  password: {
./src/models/User.js:      if (user.password) {
./src/models/User.js:        user.password = await bcrypt.hash(user.password, 10);
./src/models/User.js:      if (user.changed('password')) {
./src/models/User.js:        user.password = await bcrypt.hash(user.password, 10);
./src/models/User.js:User.prototype.validatePassword = async function(password) {
./src/models/User.js:  return await bcrypt.compare(password, this.password);
./src/models/User.js:  delete values.password;
./src/models/userModel.js: * @returns {Promise<Object>} Created user (without password)
./src/models/userModel.js:  const { email, password, firstName, lastName, phone, role = 'customer' } = userData;
./src/models/userModel.js:  // Hash password
./src/models/userModel.js:  const hashedPassword = await hashPassword(password);
./src/models/userModel.js:    password: hashedPassword,
./src/models/userModel.js:  // Return user without password
./src/models/userModel.js:  const { password: _, ...userWithoutPassword } = user;
./src/models/userModel.js: * @returns {Promise<Object|null>} User object (without password) or null
./src/models/userModel.js:  const { password, ...userWithoutPassword } = user;
./src/models/userModel.js: * @returns {Promise<Object>} Updated user (without password)
./src/models/userModel.js:  // Handle password update
./src/models/userModel.js:  if (updateData.password) {
./src/models/userModel.js:    updateData.password = await hashPassword(updateData.password);
./src/models/userModel.js:  const { password, ...userWithoutPassword } = users[userIndex];
./src/models/userModel.js: * Authenticate user with email and password
./src/models/userModel.js: * @param {string} password - User password
./src/models/userModel.js: * @returns {Promise<Object>} User object (without password) or null
./src/models/userModel.js:const authenticateUser = async (email, password) => {
./src/models/userModel.js:  const isPasswordValid = await comparePassword(password, user.password);
./src/models/userModel.js:  const { password: _, ...userWithoutPassword } = user;
./src/models/userModel.js: * @returns {Promise<Array>} Array of users (without passwords)
./src/models/userModel.js:  // Remove passwords and sort by creation date
./src/models/userModel.js:    .map(({ password, ...user }) => user)
./src/models/userModel.js:        password: 'admin123',
./src/models/userModel.js:        password: 'Staff123!',
./src/routes/googleCalendar.js:    // Exchange code for tokens
./src/routes/googleCalendar.js:    const tokens = await googleCalendar.getTokens(code);
./src/routes/googleCalendar.js:    googleCalendar.setCredentials(tokens);
./src/routes/googleCalendar.js:      idToken: tokens.id_token,
./src/routes/googleCalendar.js:    // Save tokens to salon
./src/routes/googleCalendar.js:        accessToken: tokens.access_token,
./src/routes/googleCalendar.js:        refreshToken: tokens.refresh_token,
./src/routes/googleCalendar.js:        expiryDate: tokens.expiry_date,
./src/routes/googleCalendar.js:          access_token: salon.integrations.googleCalendar.accessToken
./src/routes/googleCalendar.js:    const tokens = salon.integrations?.googleCalendar;
./src/routes/googleCalendar.js:    if (!tokens?.refreshToken) {
./src/routes/googleCalendar.js:    // Refresh token if needed
./src/routes/googleCalendar.js:    if (tokens.expiryDate < Date.now()) {
./src/routes/googleCalendar.js:      const newTokens = await googleCalendar.refreshAccessToken(tokens.refreshToken);
./src/routes/googleCalendar.js:      tokens.accessToken = newTokens.access_token;
./src/routes/googleCalendar.js:      tokens.expiryDate = newTokens.expiry_date;
./src/routes/googleCalendar.js:        'integrations.googleCalendar.accessToken': newTokens.access_token,
./src/routes/googleCalendar.js:        tokens
./src/routes/googleCalendar.js:        tokens
./src/routes/googleCalendar.js:    const tokens = salon.integrations?.googleCalendar;
./src/routes/googleCalendar.js:    if (!tokens?.refreshToken) {
./src/routes/googleCalendar.js:    const results = await googleCalendar.batchSyncAppointments(appointments, tokens);
./src/routes/googleCalendar.js:    const tokens = salon.integrations?.googleCalendar;
./src/routes/googleCalendar.js:    if (!tokens?.refreshToken) {
./src/routes/googleCalendar.js:    const isAvailable = await googleCalendar.checkAvailability(start, end, tokens);
./src/routes/authRoutes.js:  body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters long'),
./src/routes/authRoutes.js:  body('newPassword').isLength({ min: 8 }).withMessage('New password must be at least 8 characters long')
./src/routes/authRoutes.js:  const { email, password, firstName, lastName, phone, role } = req.body;
./src/routes/authRoutes.js:  // Validate password strength
./src/routes/authRoutes.js:  const passwordValidation = validatePassword(password);
./src/routes/authRoutes.js:  if (!passwordValidation.isValid) {
./src/routes/authRoutes.js:    password,
./src/routes/authRoutes.js:  // Generate tokens
./src/routes/authRoutes.js:  const tokenPayload = {
./src/routes/authRoutes.js:  const accessToken = generateToken(tokenPayload);
./src/routes/authRoutes.js:  const refreshToken = generateRefreshToken(tokenPayload);
./src/routes/authRoutes.js:    passwordStrength: passwordValidation.strength
./src/routes/authRoutes.js: * @desc    Authenticate user and get token
./src/routes/authRoutes.js:  const { email, password } = req.body;
./src/routes/authRoutes.js:  const user = await authenticateUser(email, password);
./src/routes/authRoutes.js:  // Generate tokens
./src/routes/authRoutes.js:  const tokenPayload = {
./src/routes/authRoutes.js:  const accessToken = generateToken(tokenPayload);
./src/routes/authRoutes.js:  const refreshToken = generateRefreshToken(tokenPayload);
./src/routes/authRoutes.js: * @desc    Refresh access token using refresh token
./src/routes/authRoutes.js:    // Generate new tokens
./src/routes/authRoutes.js:    const tokenPayload = {
./src/routes/authRoutes.js:    const newAccessToken = generateToken(tokenPayload);
./src/routes/authRoutes.js:    const newRefreshToken = generateRefreshToken(tokenPayload);
./src/routes/authRoutes.js:      error: 'Invalid or expired refresh token',
./src/routes/authRoutes.js: * @route   PUT /api/auth/change-password
./src/routes/authRoutes.js: * @desc    Change user password
./src/routes/authRoutes.js:router.put('/change-password', 
./src/routes/authRoutes.js:    // Verify current password
./src/routes/authRoutes.js:        error: 'Current password is incorrect',
./src/routes/authRoutes.js:    // Validate new password strength
./src/routes/authRoutes.js:    const passwordValidation = validatePassword(newPassword);
./src/routes/authRoutes.js:    if (!passwordValidation.isValid) {
./src/routes/authRoutes.js:    await updateUser(req.user.userId, { password: newPassword });
./src/routes/authRoutes.js:      passwordStrength: passwordValidation.strength
./src/routes/authRoutes.js: * @desc    Logout user (client-side token removal)
./src/routes/authRoutes.js:  // In a production app, you might want to implement token blacklisting
./src/routes/authRoutes.js:  // For now, we rely on client-side token removal
./src/routes/auth.js:  body('password').isLength({ min: 8 }).withMessage('Password must be at least 8 characters'),
./src/routes/auth.js:    const { email, password, name, salonName, phoneNumber } = req.body;
./src/routes/auth.js:      password,
./src/routes/auth.js:    // Generate token
./src/routes/auth.js:    const token = jwt.sign(
./src/routes/auth.js:      token
./src/routes/auth.js:  body('password').notEmpty(),
./src/routes/auth.js:    const { email, password } = req.body;
./src/routes/auth.js:    if (!user || !await user.validatePassword(password)) {
./src/routes/auth.js:    // Generate token
./src/routes/auth.js:    const token = jwt.sign(
./src/routes/auth.js:      token
./src/routes/auth.js:// Change password
./src/routes/auth.js:router.post('/change-password', authMiddleware, [
./src/routes/auth.js:    // Validate current password
./src/routes/auth.js:      return res.status(401).json({ message: 'Current password is incorrect' });
./src/routes/auth.js:    // Update password
./src/routes/auth.js:    await req.user.update({ password: newPassword });
./src/routes/auth.js:    console.error('Change password error:', error);
./src/routes/auth.js:    res.status(500).json({ message: 'Failed to change password' });
./src/app.js:      header: 'Authorization: Bearer <token>'
./src/app.js:      error: 'Invalid token',
./src/app.js:      message: 'Please refresh your authentication token'
./src/services/googleCalendar.js:      state: salonId // Pass salon ID to link tokens later
./src/services/googleCalendar.js:  // Exchange authorization code for tokens
./src/services/googleCalendar.js:      const { tokens } = await this.oauth2Client.getToken(code);
./src/services/googleCalendar.js:      return tokens;
./src/services/googleCalendar.js:      console.error('Error getting tokens:', error);
./src/services/googleCalendar.js:  setCredentials(tokens) {
./src/services/googleCalendar.js:    this.oauth2Client.setCredentials(tokens);
./src/services/googleCalendar.js:  async createAppointmentEvent(appointment, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  async updateAppointmentEvent(eventId, appointment, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  async deleteAppointmentEvent(eventId, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  async getEvents(startDate, endDate, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  async checkAvailability(startTime, endTime, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  async batchSyncAppointments(appointments, tokens) {
./src/services/googleCalendar.js:    this.setCredentials(tokens);
./src/services/googleCalendar.js:  // Refresh access token if expired
./src/services/googleCalendar.js:      this.oauth2Client.setCredentials({ refresh_token: refreshToken });
./src/services/googleCalendar.js:      console.error('Error refreshing access token:', error);
./src/services/googleCalendar.js:      throw new Error('Failed to refresh access token');
./src/services/googleCalendar.js:  async revokeAccess(tokens) {
./src/services/googleCalendar.js:      await this.oauth2Client.revokeCredentials(tokens.access_token);
./src/server-simple.js:  const token = req.header('Authorization')?.replace('Bearer ', '');
./src/server-simple.js:  if (!token) {
./src/server-simple.js:  const hashedPassword = await bcrypt.hash('password123', 10);
./src/server-simple.js:    password: hashedPassword,
./src/server-simple.js:  console.log('Test account: test@salon-lumiere.com / password123');
./src/server-simple.js:    const { email, password, name, salonName, phoneNumber } = req.body;
./src/server-simple.js:    const hashedPassword = await bcrypt.hash(password, 10);
./src/server-simple.js:      password: hashedPassword,
./src/server-simple.js:    // Generate token
./src/server-simple.js:    const token = jwt.sign(
./src/server-simple.js:    delete userResponse.password;
./src/server-simple.js:      token
./src/server-simple.js:    const { email, password } = req.body;
./src/server-simple.js:    if (!user || !await bcrypt.compare(password, user.password)) {
./src/server-simple.js:    // Generate token
./src/server-simple.js:    const token = jwt.sign(
./src/server-simple.js:    delete userResponse.password;
./src/server-simple.js:      token
./src/server-simple.js:  delete userResponse.password;
./src/server-simple.js:  delete userResponse.password;
./src/server-simple.js:      console.log('   Password: password123');
