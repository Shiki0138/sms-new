# PWA ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸

## ğŸ—ï¸ PWA ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client (PWA)                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  App Shell    â”‚  â”‚ Service      â”‚  â”‚  IndexedDB          â”‚   â”‚
â”‚  â”‚  (UI Framework)â”‚  â”‚ Worker       â”‚  â”‚  (Local Storage)    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Network Layer                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  REST API     â”‚  â”‚ WebSocket    â”‚  â”‚  Push Notification  â”‚   â”‚
â”‚  â”‚  Client       â”‚  â”‚ Connection   â”‚  â”‚  Service            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Backend Services                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Express.js   â”‚  â”‚ Firebase     â”‚  â”‚  SMS/Push Gateway   â”‚   â”‚
â”‚  â”‚  Server       â”‚  â”‚ Database     â”‚  â”‚  (Twilio/FCM)       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
pwa-salon-app/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ manifest.json          # PWA ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆ
â”‚   â”œâ”€â”€ sw.js                 # Service Worker
â”‚   â”œâ”€â”€ icons/                # ã‚¢ãƒ—ãƒªã‚¢ã‚¤ã‚³ãƒ³ï¼ˆå„ã‚µã‚¤ã‚ºï¼‰
â”‚   â””â”€â”€ offline.html          # ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚è¡¨ç¤ºãƒšãƒ¼ã‚¸
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/           # UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ common/          # æ±ç”¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ booking/         # äºˆç´„é–¢é€£
â”‚   â”‚   â”œâ”€â”€ profile/         # ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«é–¢é€£
â”‚   â”‚   â””â”€â”€ navigation/      # ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
â”‚   â”œâ”€â”€ pages/               # ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ Home.jsx
â”‚   â”‚   â”œâ”€â”€ Booking.jsx
â”‚   â”‚   â”œâ”€â”€ History.jsx
â”‚   â”‚   â””â”€â”€ Profile.jsx
â”‚   â”œâ”€â”€ hooks/               # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â”‚   â”‚   â”œâ”€â”€ useAuth.js
â”‚   â”‚   â”œâ”€â”€ useOfflineSync.js
â”‚   â”‚   â”œâ”€â”€ usePushNotification.js
â”‚   â”‚   â””â”€â”€ useLocalStorage.js
â”‚   â”œâ”€â”€ services/            # APIãƒ»ã‚µãƒ¼ãƒ“ã‚¹å±¤
â”‚   â”‚   â”œâ”€â”€ api.js           # API client
â”‚   â”‚   â”œâ”€â”€ storage.js       # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
â”‚   â”‚   â”œâ”€â”€ notifications.js # é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”‚   â””â”€â”€ sync.js          # ãƒ‡ãƒ¼ã‚¿åŒæœŸ
â”‚   â”œâ”€â”€ utils/               # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â”œâ”€â”€ constants.js
â”‚   â”‚   â”œâ”€â”€ helpers.js
â”‚   â”‚   â””â”€â”€ validators.js
â”‚   â”œâ”€â”€ styles/              # ã‚¹ã‚¿ã‚¤ãƒ«
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ pages/
â”‚   â”œâ”€â”€ App.jsx              # ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â””â”€â”€ index.js             # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ package.json
â”œâ”€â”€ vite.config.js           # Viteè¨­å®š
â””â”€â”€ vercel.json              # Vercelè¨­å®š
```

---

## ğŸ“„ PWA ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆ

```json
// public/manifest.json
{
  "name": "Salon LumiÃ¨re - ç¾å®¹å®¤äºˆç´„ã‚¢ãƒ—ãƒª",
  "short_name": "SalonLumiere",
  "description": "ç¾å®¹å®¤Salon LumiÃ¨reã®å…¬å¼äºˆç´„ã‚¢ãƒ—ãƒª",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#d4a574",
  "background_color": "#ffffff",
  "lang": "ja",
  "categories": ["lifestyle", "beauty"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png", 
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128", 
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png", 
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384", 
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "æ–°ã—ã„äºˆç´„",
      "short_name": "äºˆç´„",
      "description": "æ–°ã—ã„äºˆç´„ã‚’ä½œæˆ",
      "url": "/booking",
      "icons": [
        {
          "src": "/icons/shortcut-booking.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "äºˆç´„å±¥æ­´",
      "short_name": "å±¥æ­´", 
      "description": "éå»ã®äºˆç´„ã‚’ç¢ºèª",
      "url": "/history",
      "icons": [
        {
          "src": "/icons/shortcut-history.png",
          "sizes": "96x96"
        }
      ]
    }
  ],
  "prefer_related_applications": false,
  "related_applications": []
}
```

---

## ğŸ”§ Service Worker å®Ÿè£…

```javascript
// public/sw.js
const CACHE_NAME = 'salon-lumiere-v1.2.0';
const OFFLINE_URL = '/offline.html';

// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹
const STATIC_CACHE_URLS = [
  '/',
  '/offline.html',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
  // CSSãƒ»JSãƒ•ã‚¡ã‚¤ãƒ«ã¯å‹•çš„ã«è¿½åŠ 
];

// API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
const API_CACHE_URLS = [
  '/api/profile',
  '/api/appointments',
  '/api/services'
];

// ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆ
self.addEventListener('install', (event) => {
  console.log('[SW] Installing...');
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[SW] Caching static resources');
        return cache.addAll(STATIC_CACHE_URLS);
      })
      .then(() => {
        return self.skipWaiting();
      })
  );
});

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating...');
  
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      return self.clients.claim();
    })
  );
});

// ãƒ•ã‚§ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ï¼‰
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request));
    return;
  }

  // é™çš„ãƒªã‚½ãƒ¼ã‚¹ã®å‡¦ç†
  if (request.method === 'GET') {
    event.respondWith(handleStaticRequest(request));
    return;
  }
});

// API ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ï¼ˆNetwork Firstæˆ¦ç•¥ï¼‰
async function handleApiRequest(request) {
  const cache = await caches.open(CACHE_NAME);
  
  try {
    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰å–å¾—ã‚’è©¦è¡Œ
    const response = await fetch(request);
    
    if (response.ok) {
      // æˆåŠŸæ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
      const responseClone = response.clone();
      await cache.put(request, responseClone);
    }
    
    return response;
  } catch (error) {
    console.log('[SW] Network failed, serving from cache:', request.url);
    
    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¤±æ•—æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰è¿”ã™
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚‚ãªã„å ´åˆã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¿œç­”
    return new Response(
      JSON.stringify({ 
        error: 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ã€ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“',
        offline: true 
      }),
      {
        status: 503,
        statusText: 'Service Unavailable',
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

// é™çš„ãƒªã‚½ãƒ¼ã‚¹å‡¦ç†ï¼ˆCache Firstæˆ¦ç•¥ï¼‰
async function handleStaticRequest(request) {
  const cache = await caches.open(CACHE_NAME);
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰æ›´æ–°
    fetch(request).then((response) => {
      if (response.ok) {
        cache.put(request, response.clone());
      }
    }).catch(() => {
      // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
    });
    
    return cachedResponse;
  }
  
  try {
    const response = await fetch(request);
    
    if (response.ok) {
      await cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // HTMLãƒšãƒ¼ã‚¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®å ´åˆ
    if (request.headers.get('accept')?.includes('text/html')) {
      return cache.match(OFFLINE_URL);
    }
    
    throw error;
  }
}

// ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥ã‚¤ãƒ™ãƒ³ãƒˆ
self.addEventListener('push', (event) => {
  console.log('[SW] Push received');
  
  const options = {
    body: 'æ–°ã—ã„é€šçŸ¥ãŒã‚ã‚Šã¾ã™',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    },
    actions: [
      {
        action: 'view',
        title: 'ç¢ºèª',
        icon: '/icons/action-view.png'
      },
      {
        action: 'close',
        title: 'é–‰ã˜ã‚‹',
        icon: '/icons/action-close.png'
      }
    ]
  };

  if (event.data) {
    const payload = event.data.json();
    options.title = payload.title || 'Salon LumiÃ¨re';
    options.body = payload.body || options.body;
    options.icon = payload.icon || options.icon;
    options.data = { ...options.data, ...payload.data };
  }

  event.waitUntil(
    self.registration.showNotification('Salon LumiÃ¨re', options)
  );
});

// é€šçŸ¥ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification click');
  
  event.notification.close();
  
  const action = event.action;
  const data = event.notification.data;
  
  if (action === 'view') {
    event.waitUntil(
      clients.openWindow(data.url || '/')
    );
  }
});

// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸ
self.addEventListener('sync', (event) => {
  console.log('[SW] Background sync:', event.tag);
  
  if (event.tag === 'appointment-sync') {
    event.waitUntil(syncAppointments());
  }
  
  if (event.tag === 'profile-sync') {
    event.waitUntil(syncProfile());
  }
});

// äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
async function syncAppointments() {
  try {
    // IndexedDBã‹ã‚‰æœªåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const pendingAppointments = await getPendingAppointments();
    
    for (const appointment of pendingAppointments) {
      try {
        const response = await fetch('/api/appointments', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${appointment.token}`
          },
          body: JSON.stringify(appointment.data)
        });
        
        if (response.ok) {
          await removePendingAppointment(appointment.id);
          console.log('[SW] Appointment synced:', appointment.id);
        }
      } catch (error) {
        console.error('[SW] Failed to sync appointment:', error);
      }
    }
  } catch (error) {
    console.error('[SW] Background sync failed:', error);
  }
}

// ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
async function syncProfile() {
  try {
    // å®Ÿè£…è©³ç´°
    console.log('[SW] Profile sync completed');
  } catch (error) {
    console.error('[SW] Profile sync failed:', error);
  }
}

// IndexedDBæ“ä½œãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆå®Ÿè£…è©³ç´°ã¯åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
function getPendingAppointments() {
  // IndexedDBã‹ã‚‰å–å¾—
  return Promise.resolve([]);
}

function removePendingAppointment(id) {
  // IndexedDBã‹ã‚‰å‰Šé™¤
  return Promise.resolve();
}
```

---

## ğŸ’¾ ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æˆ¦ç•¥

### IndexedDB è¨­è¨ˆ

```javascript
// src/services/storage.js
import { openDB } from 'idb';

const DB_NAME = 'SalonLumiereDB';
const DB_VERSION = 1;

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒ
const STORES = {
  appointments: {
    keyPath: 'id',
    indexes: [
      { name: 'date', keyPath: 'appointmentDate' },
      { name: 'status', keyPath: 'status' },
      { name: 'userId', keyPath: 'userId' }
    ]
  },
  profile: {
    keyPath: 'userId'
  },
  services: {
    keyPath: 'id',
    indexes: [
      { name: 'category', keyPath: 'category' },
      { name: 'active', keyPath: 'active' }
    ]
  },
  syncQueue: {
    keyPath: 'id',
    autoIncrement: true,
    indexes: [
      { name: 'type', keyPath: 'type' },
      { name: 'timestamp', keyPath: 'timestamp' }
    ]
  },
  settings: {
    keyPath: 'key'
  }
};

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
async function initDB() {
  return await openDB(DB_NAME, DB_VERSION, {
    upgrade(db, oldVersion, newVersion, transaction) {
      console.log(`Upgrading DB from ${oldVersion} to ${newVersion}`);
      
      // å„ã‚¹ãƒˆã‚¢ã®ä½œæˆ
      Object.entries(STORES).forEach(([storeName, config]) => {
        if (!db.objectStoreNames.contains(storeName)) {
          const store = db.createObjectStore(storeName, {
            keyPath: config.keyPath,
            autoIncrement: config.autoIncrement || false
          });
          
          // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½œæˆ
          if (config.indexes) {
            config.indexes.forEach(({ name, keyPath, unique = false }) => {
              store.createIndex(name, keyPath, { unique });
            });
          }
        }
      });
    }
  });
}

// ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤
class StorageService {
  constructor() {
    this.db = null;
    this.init();
  }

  async init() {
    this.db = await initDB();
  }

  // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®æ“ä½œ
  async saveAppointment(appointment) {
    const tx = this.db.transaction('appointments', 'readwrite');
    await tx.objectStore('appointments').put({
      ...appointment,
      lastUpdated: new Date().toISOString(),
      synced: false
    });
    await tx.done;
  }

  async getAppointments(userId, limit = 50) {
    const tx = this.db.transaction('appointments', 'readonly');
    const store = tx.objectStore('appointments');
    const index = store.index('userId');
    
    const appointments = await index.getAll(userId);
    
    return appointments
      .sort((a, b) => new Date(b.appointmentDate) - new Date(a.appointmentDate))
      .slice(0, limit);
  }

  async getUpcomingAppointments(userId) {
    const now = new Date().toISOString();
    const appointments = await this.getAppointments(userId);
    
    return appointments.filter(apt => 
      apt.appointmentDate >= now && 
      apt.status !== 'cancelled'
    );
  }

  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã®æ“ä½œ
  async saveProfile(profile) {
    const tx = this.db.transaction('profile', 'readwrite');
    await tx.objectStore('profile').put({
      ...profile,
      lastUpdated: new Date().toISOString()
    });
    await tx.done;
  }

  async getProfile(userId) {
    const tx = this.db.transaction('profile', 'readonly');
    return await tx.objectStore('profile').get(userId);
  }

  // åŒæœŸã‚­ãƒ¥ãƒ¼ã®æ“ä½œ
  async addToSyncQueue(type, data, userId) {
    const tx = this.db.transaction('syncQueue', 'readwrite');
    await tx.objectStore('syncQueue').add({
      type,
      data,
      userId,
      timestamp: new Date().toISOString(),
      attempts: 0
    });
    await tx.done;
  }

  async getSyncQueue() {
    const tx = this.db.transaction('syncQueue', 'readonly');
    return await tx.objectStore('syncQueue').getAll();
  }

  async removeSyncQueueItem(id) {
    const tx = this.db.transaction('syncQueue', 'readwrite');
    await tx.objectStore('syncQueue').delete(id);
    await tx.done;
  }

  // è¨­å®šã®æ“ä½œ
  async saveSetting(key, value) {
    const tx = this.db.transaction('settings', 'readwrite');
    await tx.objectStore('settings').put({ key, value });
    await tx.done;
  }

  async getSetting(key, defaultValue = null) {
    const tx = this.db.transaction('settings', 'readonly');
    const result = await tx.objectStore('settings').get(key);
    return result ? result.value : defaultValue;
  }

  // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ï¼ˆãƒ­ã‚°ã‚¢ã‚¦ãƒˆæ™‚ãªã©ï¼‰
  async clearUserData(userId) {
    const tx = this.db.transaction(['appointments', 'profile', 'syncQueue'], 'readwrite');
    
    // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
    const appointmentStore = tx.objectStore('appointments');
    const appointmentIndex = appointmentStore.index('userId');
    const appointments = await appointmentIndex.getAllKeys(userId);
    await Promise.all(appointments.map(key => appointmentStore.delete(key)));
    
    // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
    await tx.objectStore('profile').delete(userId);
    
    // åŒæœŸã‚­ãƒ¥ãƒ¼ã®å‰Šé™¤
    const syncStore = tx.objectStore('syncQueue');
    const syncIndex = syncStore.index('userId');  
    const syncItems = await syncIndex.getAllKeys(userId);
    await Promise.all(syncItems.map(key => syncStore.delete(key)));
    
    await tx.done;
  }

  // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã®ç¢ºèª
  async getStorageUsage() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return {
        usage: estimate.usage,
        quota: estimate.quota,
        usagePercentage: ((estimate.usage / estimate.quota) * 100).toFixed(2)
      };
    }
    return null;
  }
}

export const storageService = new StorageService();
```

---

## ğŸ”„ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åŒæœŸã‚·ã‚¹ãƒ†ãƒ 

```javascript
// src/services/sync.js
import { storageService } from './storage.js';
import { apiClient } from './api.js';

class SyncService {
  constructor() {
    this.isOnline = navigator.onLine;
    this.syncInProgress = false;
    this.registerEventListeners();
    this.schedulePeriodicSync();
  }

  registerEventListeners() {
    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹ã®ç›£è¦–
    window.addEventListener('online', () => {
      console.log('[Sync] Back online');
      this.isOnline = true;
      this.performSync();
    });

    window.addEventListener('offline', () => {
      console.log('[Sync] Gone offline');
      this.isOnline = false;
    });

    // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸã®ç™»éŒ²
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      navigator.serviceWorker.ready.then((registration) => {
        this.swRegistration = registration;
      });
    }

    // ãƒšãƒ¼ã‚¸ã®å¯è¦–æ€§å¤‰æ›´
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && this.isOnline) {
        this.performSync();
      }
    });
  }

  // å®šæœŸåŒæœŸã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
  schedulePeriodicSync() {
    setInterval(() => {
      if (this.isOnline && !document.hidden) {
        this.performSync();
      }
    }, 5 * 60 * 1000); // 5åˆ†é–“éš”
  }

  // åŒæœŸå®Ÿè¡Œ
  async performSync() {
    if (this.syncInProgress || !this.isOnline) {
      return;
    }

    this.syncInProgress = true;
    console.log('[Sync] Starting sync...');

    try {
      // 1. ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰åŒæœŸï¼ˆãƒ­ãƒ¼ã‚«ãƒ«â†’ã‚µãƒ¼ãƒãƒ¼ï¼‰
      await this.syncUploads();
      
      // 2. ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰åŒæœŸï¼ˆã‚µãƒ¼ãƒãƒ¼â†’ãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
      await this.syncDownloads();
      
      // 3. æœ€çµ‚åŒæœŸæ™‚åˆ»ã®æ›´æ–°
      await storageService.saveSetting('lastSyncTime', new Date().toISOString());
      
      console.log('[Sync] Sync completed successfully');
      this.dispatchSyncEvent('success');
      
    } catch (error) {
      console.error('[Sync] Sync failed:', error);
      this.dispatchSyncEvent('error', error);
    } finally {
      this.syncInProgress = false;
    }
  }

  // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰åŒæœŸ
  async syncUploads() {
    const syncQueue = await storageService.getSyncQueue();
    
    for (const item of syncQueue) {
      try {
        let result;
        
        switch (item.type) {
          case 'appointment_create':
            result = await apiClient.post('/appointments', item.data);
            break;
          case 'appointment_update':
            result = await apiClient.put(`/appointments/${item.data.id}`, item.data);
            break;
          case 'appointment_cancel':
            result = await apiClient.delete(`/appointments/${item.data.id}`);
            break;
          case 'profile_update':
            result = await apiClient.put('/profile', item.data);
            break;
          default:
            console.warn('[Sync] Unknown sync type:', item.type);
            continue;
        }

        if (result.ok) {
          await storageService.removeSyncQueueItem(item.id);
          console.log(`[Sync] Synced ${item.type}:`, item.id);
        }
        
      } catch (error) {
        console.error(`[Sync] Failed to sync ${item.type}:`, error);
        
        // ãƒªãƒˆãƒ©ã‚¤å›æ•°ã‚’å¢—ã‚„ã™
        item.attempts = (item.attempts || 0) + 1;
        
        // æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°ã«é”ã—ãŸå ´åˆã¯å‰Šé™¤
        if (item.attempts >= 3) {
          await storageService.removeSyncQueueItem(item.id);
          console.warn('[Sync] Max retries reached, removing item:', item.id);
        }
      }
    }
  }

  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰åŒæœŸ
  async syncDownloads() {
    const userId = await storageService.getSetting('userId');
    if (!userId) return;

    const lastSyncTime = await storageService.getSetting('lastSyncTime');
    
    try {
      // äºˆç´„ãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
      const appointmentsResponse = await apiClient.get(`/appointments`, {
        params: { 
          userId,
          since: lastSyncTime 
        }
      });
      
      if (appointmentsResponse.ok) {
        const appointments = await appointmentsResponse.json();
        for (const appointment of appointments) {
          await storageService.saveAppointment({
            ...appointment,
            synced: true
          });
        }
      }

      // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«åŒæœŸ
      const profileResponse = await apiClient.get('/profile');
      if (profileResponse.ok) {
        const profile = await profileResponse.json();
        await storageService.saveProfile(profile);
      }

      // ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã®åŒæœŸ
      const servicesResponse = await apiClient.get('/services');
      if (servicesResponse.ok) {
        const services = await servicesResponse.json();
        // ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±ã‚’ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
        for (const service of services) {
          await this.saveServiceToStorage(service);
        }
      }

    } catch (error) {
      console.error('[Sync] Download sync failed:', error);
      throw error;
    }
  }

  // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸã®ç™»éŒ²
  async registerBackgroundSync(tag = 'appointment-sync') {
    if (this.swRegistration) {
      try {
        await this.swRegistration.sync.register(tag);
        console.log('[Sync] Background sync registered:', tag);
      } catch (error) {
        console.error('[Sync] Background sync registration failed:', error);
      }
    }
  }

  // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ“ä½œã®ä¿å­˜
  async saveOfflineAction(type, data) {
    const userId = await storageService.getSetting('userId');
    await storageService.addToSyncQueue(type, data, userId);
    
    // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸã‚’è©¦è¡Œ
    await this.registerBackgroundSync();
    
    console.log('[Sync] Offline action saved:', type);
  }

  // åŒæœŸã‚¤ãƒ™ãƒ³ãƒˆã®é…ä¿¡
  dispatchSyncEvent(type, detail = null) {
    const event = new CustomEvent(`sync-${type}`, {
      detail: {
        timestamp: new Date().toISOString(),
        ...detail
      }
    });
    window.dispatchEvent(event);
  }

  // åŒæœŸçŠ¶æ…‹ã®å–å¾—
  async getSyncStatus() {
    const lastSyncTime = await storageService.getSetting('lastSyncTime');
    const syncQueue = await storageService.getSyncQueue();
    
    return {
      lastSyncTime,
      pendingItems: syncQueue.length,
      isOnline: this.isOnline,
      syncInProgress: this.syncInProgress
    };
  }
}

export const syncService = new SyncService();
```

---

## ğŸ“² ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥å®Ÿè£…

```javascript
// src/services/notifications.js
class NotificationService {
  constructor() {
    this.permission = Notification.permission;
    this.vapidPublicKey = 'YOUR_VAPID_PUBLIC_KEY'; // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—
  }

  // é€šçŸ¥è¨±å¯ã®è¦æ±‚
  async requestPermission() {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      this.permission = permission;
      
      if (permission === 'granted') {
        await this.subscribeToPush();
      }
      
      return permission;
    }
    return 'unsupported';
  }

  // ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥ã®è³¼èª­
  async subscribeToPush() {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      try {
        const registration = await navigator.serviceWorker.ready;
        
        const subscription = await registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: this.urlBase64ToUint8Array(this.vapidPublicKey)
        });

        // ã‚µãƒ¼ãƒãƒ¼ã«è³¼èª­æƒ…å ±ã‚’é€ä¿¡
        await this.sendSubscriptionToServer(subscription);
        
        return subscription;
      } catch (error) {
        console.error('[Notification] Push subscription failed:', error);
        throw error;
      }
    }
  }

  // ãƒ­ãƒ¼ã‚«ãƒ«é€šçŸ¥ã®è¡¨ç¤º
  async showLocalNotification(title, options = {}) {
    if (this.permission === 'granted') {
      const defaultOptions = {
        body: '',
        icon: '/icons/icon-192x192.png',
        badge: '/icons/icon-72x72.png',
        vibrate: [100, 50, 100],
        requireInteraction: false,
        silent: false,
        ...options
      };

      return new Notification(title, defaultOptions);
    }
  }

  // äºˆç´„ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼é€šçŸ¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  async scheduleAppointmentReminder(appointment) {
    const reminderTime = new Date(appointment.appointmentDate);
    reminderTime.setHours(reminderTime.getHours() - 24); // 24æ™‚é–“å‰

    const now = new Date();
    const delay = reminderTime.getTime() - now.getTime();

    if (delay > 0) {
      setTimeout(() => {
        this.showLocalNotification('äºˆç´„ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼', {
          body: `æ˜æ—¥ ${appointment.startTime} ã‹ã‚‰ã”äºˆç´„ãŒã‚ã‚Šã¾ã™`,
          tag: `reminder-${appointment.id}`,
          data: {
            type: 'reminder',
            appointmentId: appointment.id,
            url: '/appointments'
          },
          actions: [
            {
              action: 'view',
              title: 'è©³ç´°ã‚’è¦‹ã‚‹'
            },
            {
              action: 'reschedule',
              title: 'å¤‰æ›´ã™ã‚‹'
            }
          ]
        });
      }, delay);
    }
  }

  // ãƒãƒƒã‚¸ã‚«ã‚¦ãƒ³ãƒˆã®æ›´æ–°
  async updateBadge(count = 0) {
    if ('setAppBadge' in navigator) {
      try {
        if (count > 0) {
          await navigator.setAppBadge(count);
        } else {
          await navigator.clearAppBadge();
        }
      } catch (error) {
        console.error('[Notification] Badge update failed:', error);
      }
    }
  }

  // ã‚µãƒ¼ãƒãƒ¼ã«è³¼èª­æƒ…å ±ã‚’é€ä¿¡
  async sendSubscriptionToServer(subscription) {
    const response = await fetch('/api/push-subscription', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify({
        subscription,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString()
      })
    });

    if (!response.ok) {
      throw new Error('Failed to send subscription to server');
    }
  }

  // VAPID ã‚­ãƒ¼ã®å¤‰æ›
  urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
    
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    
    return outputArray;
  }
}

export const notificationService = new NotificationService();
```

---

## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### Viteè¨­å®š

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\./,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          },
          {
            urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'image-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 30 * 24 * 60 * 60 // 30æ—¥
              }
            }
          }
        ]
      },
      manifest: {
        // manifest.jsonã®å†…å®¹ã‚’ã“ã“ã«é…ç½®
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          utils: ['date-fns', 'framer-motion'],
        }
      }
    }
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true
      }
    }
  }
});
```

ã“ã® PWA ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã«ã‚ˆã‚Šã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã€ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥ã€é«˜é€Ÿèª­ã¿è¾¼ã¿ã‚’å®Ÿç¾ã—ãŸç¾å®¹å®¤é¡§å®¢å‘ã‘ã‚¢ãƒ—ãƒªã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚