const twilioService = require('./twilioService');\nconst logger = require('../utils/logger');\nconst SmsTemplate = require('../models/SmsTemplate');\nconst SmsSegment = require('../models/SmsSegment');\nconst SmsRecipient = require('../models/SmsRecipient');\nconst SmsAnalytics = require('../models/SmsAnalytics');\nconst { v4: uuidv4 } = require('uuid');\n\n/**\n * Enhanced SMS Service for SMS Blast Campaigns\n * Integrates with existing Twilio service while adding campaign management\n */\nclass EnhancedSmsService {\n  constructor() {\n    this.twilioService = twilioService;\n    this.activeJobs = new Map(); // Track active sending jobs\n    this.rateLimiter = {\n      maxPerSecond: 1,\n      queue: [],\n      processing: false\n    };\n  }\n\n  /**\n   * Create and send SMS campaign\n   * @param {Object} campaignData - Campaign configuration\n   * @param {Array} customers - Target customers\n   * @returns {Promise<Object>} Campaign results\n   */\n  async sendCampaign(campaignData, customers = []) {\n    try {\n      const campaignId = campaignData.id || uuidv4();\n      \n      logger.info('Starting SMS campaign', {\n        campaignId,\n        name: campaignData.name,\n        recipientCount: customers.length\n      });\n\n      // Apply segmentation if specified\n      let targetCustomers = customers;\n      if (campaignData.segmentId) {\n        // This would typically load from database\n        // For now, apply basic filtering\n        targetCustomers = this.applySegmentation(customers, campaignData.targetCriteria);\n      }\n\n      // Filter customers with valid phone numbers\n      const validCustomers = targetCustomers.filter(customer => \n        customer.phoneNumber && customer.phoneNumber.trim().length > 0\n      );\n\n      if (validCustomers.length === 0) {\n        throw new Error('No valid phone numbers found in target segment');\n      }\n\n      // Create recipients\n      const recipients = validCustomers.map(customer => {\n        const personalizedContent = this.personalizeMessage(\n          campaignData.messageContent,\n          customer\n        );\n\n        return new SmsRecipient({\n          id: uuidv4(),\n          campaignId,\n          customerId: customer.id,\n          phoneNumber: customer.phoneNumber,\n          personalizedContent,\n          status: 'pending'\n        });\n      });\n\n      // Send messages with rate limiting\n      const sendResults = await this.sendBulkWithRateLimit(recipients, campaignData);\n\n      // Calculate analytics\n      const analytics = new SmsAnalytics({\n        id: uuidv4(),\n        campaignId,\n        userId: campaignData.userId\n      });\n      analytics.calculateMetrics(recipients);\n\n      const summary = {\n        campaignId,\n        totalRecipients: recipients.length,\n        sent: sendResults.filter(r => r.success).length,\n        failed: sendResults.filter(r => !r.success).length,\n        analytics: analytics.getPerformanceSummary(),\n        insights: analytics.generateInsights(),\n        estimatedCost: this.calculateCost(recipients.length),\n        recipients: recipients.map(r => r.toJSON()),\n        sendResults\n      };\n\n      logger.info('SMS campaign completed', {\n        campaignId,\n        summary\n      });\n\n      return summary;\n\n    } catch (error) {\n      logger.error('SMS campaign failed', {\n        campaignId: campaignData.id,\n        error: error.message\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Send SMS with rate limiting\n   * @param {Array} recipients - SMS recipients\n   * @param {Object} campaignData - Campaign configuration\n   * @returns {Promise<Array>} Send results\n   */\n  async sendBulkWithRateLimit(recipients, campaignData) {\n    const results = [];\n    const batchSize = campaignData.settings?.sendRate || 1;\n    const delay = 1000; // 1 second delay between batches\n\n    for (let i = 0; i < recipients.length; i += batchSize) {\n      const batch = recipients.slice(i, i + batchSize);\n      \n      // Process batch\n      const batchResults = await Promise.all(\n        batch.map(recipient => this.sendSingleSms(recipient))\n      );\n      \n      results.push(...batchResults);\n\n      // Apply rate limiting delay (except for last batch)\n      if (i + batchSize < recipients.length) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      // Log progress\n      const progress = Math.round((i + batch.length) / recipients.length * 100);\n      logger.info(`SMS campaign progress: ${progress}%`, {\n        campaignId: campaignData.id,\n        sent: i + batch.length,\n        total: recipients.length\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Send single SMS\n   * @param {SmsRecipient} recipient - SMS recipient\n   * @returns {Promise<Object>} Send result\n   */\n  async sendSingleSms(recipient) {\n    try {\n      const result = await this.twilioService.sendSMS({\n        to: recipient.phoneNumber,\n        message: recipient.personalizedContent\n      });\n\n      if (result.success) {\n        recipient.updateStatus('sent', {\n          messageId: result.messageId,\n          sentAt: new Date()\n        });\n      } else {\n        recipient.updateStatus('failed', {\n          errorMessage: result.error,\n          failedAt: new Date()\n        });\n      }\n\n      return {\n        recipientId: recipient.id,\n        phone: recipient.phoneNumber,\n        success: result.success,\n        messageId: result.messageId,\n        error: result.error\n      };\n\n    } catch (error) {\n      recipient.updateStatus('failed', {\n        errorMessage: error.message,\n        failedAt: new Date()\n      });\n\n      return {\n        recipientId: recipient.id,\n        phone: recipient.phoneNumber,\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Personalize message content with customer data\n   * @param {string} template - Message template\n   * @param {Object} customer - Customer data\n   * @returns {string} Personalized message\n   */\n  personalizeMessage(template, customer) {\n    let personalized = template;\n\n    // Basic variable replacements\n    const replacements = {\n      firstName: customer.firstName || '',\n      lastName: customer.lastName || '',\n      fullName: `${customer.lastName || ''} ${customer.firstName || ''}`.trim(),\n      phoneNumber: customer.phoneNumber || '',\n      email: customer.email || '',\n      visitCount: customer.visitCount || 0,\n      lastVisitDate: customer.lastVisitDate ? \n        new Date(customer.lastVisitDate).toLocaleDateString('ja-JP') : '初回',\n      totalSales: customer.totalSales || 0\n    };\n\n    // Replace variables in template\n    Object.entries(replacements).forEach(([key, value]) => {\n      const regex = new RegExp(`{{${key}}}`, 'g');\n      personalized = personalized.replace(regex, value);\n    });\n\n    return personalized;\n  }\n\n  /**\n   * Apply customer segmentation\n   * @param {Array} customers - All customers\n   * @param {Object} criteria - Segmentation criteria\n   * @returns {Array} Filtered customers\n   */\n  applySegmentation(customers, criteria) {\n    if (!criteria || Object.keys(criteria).length === 0) {\n      return customers;\n    }\n\n    const segment = new SmsSegment({ criteria });\n    return segment.filterCustomers(customers);\n  }\n\n  /**\n   * Schedule SMS campaign\n   * @param {Object} campaignData - Campaign configuration\n   * @param {Date} scheduledTime - When to send\n   * @returns {Promise<Object>} Schedule result\n   */\n  async scheduleCampaign(campaignData, scheduledTime) {\n    const now = new Date();\n    if (scheduledTime <= now) {\n      throw new Error('Scheduled time must be in the future');\n    }\n\n    const delay = scheduledTime.getTime() - now.getTime();\n    const campaignId = campaignData.id || uuidv4();\n\n    // Store job reference\n    const timeoutId = setTimeout(async () => {\n      try {\n        logger.info('Executing scheduled SMS campaign', {\n          campaignId,\n          scheduledTime\n        });\n\n        // This would typically load customers from database\n        // For now, return a placeholder\n        await this.sendCampaign(campaignData, []);\n        \n        this.activeJobs.delete(campaignId);\n      } catch (error) {\n        logger.error('Scheduled SMS campaign failed', {\n          campaignId,\n          error: error.message\n        });\n      }\n    }, delay);\n\n    this.activeJobs.set(campaignId, {\n      timeoutId,\n      campaignData,\n      scheduledTime\n    });\n\n    logger.info('SMS campaign scheduled', {\n      campaignId,\n      scheduledTime,\n      delayMs: delay\n    });\n\n    return {\n      campaignId,\n      scheduled: true,\n      scheduledTime,\n      delayMs: delay\n    };\n  }\n\n  /**\n   * Cancel scheduled campaign\n   * @param {string} campaignId - Campaign ID\n   * @returns {boolean} Success status\n   */\n  cancelScheduledCampaign(campaignId) {\n    const job = this.activeJobs.get(campaignId);\n    if (job) {\n      clearTimeout(job.timeoutId);\n      this.activeJobs.delete(campaignId);\n      \n      logger.info('Scheduled SMS campaign cancelled', { campaignId });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get campaign status\n   * @param {string} campaignId - Campaign ID\n   * @returns {Object|null} Campaign status\n   */\n  getCampaignStatus(campaignId) {\n    const job = this.activeJobs.get(campaignId);\n    if (job) {\n      return {\n        campaignId,\n        status: 'scheduled',\n        scheduledTime: job.scheduledTime,\n        timeRemaining: job.scheduledTime.getTime() - new Date().getTime()\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Calculate estimated campaign cost\n   * @param {number} recipientCount - Number of recipients\n   * @returns {number} Estimated cost in yen\n   */\n  calculateCost(recipientCount) {\n    // Approximate SMS cost in Japan (varies by provider)\n    const costPerSms = 3; // 3 yen per SMS\n    return recipientCount * costPerSms;\n  }\n\n  /**\n   * Validate phone number for SMS\n   * @param {string} phoneNumber - Phone number to validate\n   * @returns {Object} Validation result\n   */\n  validatePhoneNumber(phoneNumber) {\n    if (!phoneNumber || phoneNumber.trim().length === 0) {\n      return {\n        isValid: false,\n        error: 'Phone number is required'\n      };\n    }\n\n    try {\n      const formatted = this.twilioService.formatPhoneNumber(phoneNumber);\n      return {\n        isValid: true,\n        formatted\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Get service status and configuration\n   * @returns {Object} Service status\n   */\n  getStatus() {\n    return {\n      isEnabled: this.twilioService.isEnabled,\n      activeJobs: this.activeJobs.size,\n      rateLimitConfig: this.rateLimiter,\n      scheduledCampaigns: Array.from(this.activeJobs.entries()).map(([id, job]) => ({\n        campaignId: id,\n        scheduledTime: job.scheduledTime,\n        campaignName: job.campaignData.name\n      }))\n    };\n  }\n}\n\nmodule.exports = new EnhancedSmsService();